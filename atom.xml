<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[平凡的世界]]></title>
  <link href="http://linuxlsx.github.io/atom.xml" rel="self"/>
  <link href="http://linuxlsx.github.io/"/>
  <updated>2019-04-14T00:14:11+08:00</updated>
  <id>http://linuxlsx.github.io/</id>
  <author>
    <name><![CDATA[linuxlsx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Arts-week-four]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/04/14/arts-week-four/"/>
    <updated>2019-04-14T00:06:02+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/04/14/arts-week-four</id>
    <content type="html"><![CDATA[<h2>Algorithm</h2>

<p>本周完成的算法题: <a href="https://leetcode.com/problems/first-missing-positive/">First Missing Positive</a></p>

<p>本题非独立完成，根据<a href="https://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list">Find the Smallest Integer Not in a List</a> 参考实现</p>

<p>题目要求:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Text'><span class='line'>给定一个没有排序的Int数组，做到数组中不存在的最小正整数。
</span><span class='line'>
</span><span class='line'>Note:
</span><span class='line'>1. 算法复杂度必须是O(n)
</span><span class='line'>2. 使用常数个额外的空间
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p><strong>分析:</strong></p>

<p>这个题的解法很巧妙，通过利用数组的下标和其对应的值做比较就可以确定确实的最小正整数。算法运行时间至多为<code>O(3N)</code>，而且只需要一个额外的Int变量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstMissingPositive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">p</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">//第一个O(N)</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">p</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//为什么这里也只会最多执行O(N)次</span>
</span><span class='line'>        <span class="c1">//因为在条件中会判断 nums[p - 1] != p，然后在循环体里面会设置 nums[p - 1] = p</span>
</span><span class='line'>        <span class="c1">//那么每执行一次赋值，就会减少一个可赋值的位置。</span>
</span><span class='line'>        <span class="c1">//就可以保证至多执行N次</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
</span><span class='line'>            <span class="n">nums</span><span class="o">[</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span><span class='line'>            <span class="n">p</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//第三个O(N)</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">////只有数组是 [1,2,3,4] 这种情况才会走到这里</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Review</h2>

<p>本周Review <a href="https://medium.com/s/story/reflections-on-clean-code-8c9b683277ca">What is Clean Code?</a></p>

<p>本文是作者对于《Clean Code》一书的总结，从他的视角来看，可以归纳总结为三点:</p>

<ul>
<li><strong>工匠精神(Craftsmanship Matters)</strong> 可以<code>Works</code>的代码并不能说已经<code>done</code>，粗制滥造的代码会比你想象的快的出现问题。(Poorly crafted code frays at the edge much faster than you might expect.)</li>
<li><strong>今天的额外努力会减少明天的痛苦(Extra Effort Today Saves Pain Tomorrow)</strong> 就跟买衣服，鞋子一样，好的鞋子可能在价格上会高些，但是它可以穿两年、三年甚至十年，那么长远来看，这个价格就不高了。高质量的代码也是一样的，可以在开始时会困难些，但是会降低未来的技术债和维护成本。</li>
<li><strong>你写的代码不仅仅是你的(Your Code Is Not Your Own)</strong> 过于聪明的把戏，黑科技和编程技巧只是当时作者的乐趣(Overly clever tricks, hacks, and sleights of programmatic hand are only fun for the author.)，但是会给后续的维护者(也可能是你自己)带来无数的麻烦。</li>
</ul>


<p>对于什么是<code>Clean Code</code>，也总结了一下几点:</p>

<ul>
<li>Clean code is simple。虽然可能在算法或者系统层级上复杂，但是实现上要简单。少用比较冷门的技巧。</li>
<li>Clean code is readable。在命名规范、缩进、结构和流程要有良好的设计，虽然显得有些古板但是会减少后来着的理解难度。</li>
<li>Clean code is considerate。Clean code 要为后续的读者考虑，可以假设他们也是拥有同样背景和经验的人。</li>
<li>Clean code is tested。Clean code 要有充分的测试</li>
<li>Clean code is practiced。Clean code 需要多练习</li>
<li>Clean code is relentlessly refactored。Clean code 需要经常重构</li>
<li>Clean code is SOLID。遵循<a href="https://medium.com/@severinperez/writing-flexible-code-with-the-single-responsibility-principle-b71c4f3f883f">Solid 原则</a></li>
</ul>


<p>结合自身的实际来说，我觉得最重要的是 <code>tested</code> 和 <code>readable</code>。只有测试过的代码才能保证联调、测试和线上运行的时候不出现问题。另外很少有情况是你一直维护一套代码，所以让代码有良好的可读性会对后来者有很大帮助，同时自己也会有成就感。</p>

<h2>Tip</h2>

<p>本周分享一个线上排查问题时需要将日志内容按照不同的要求写到不同的文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>awk -F<span class="s1">&#39;,&#39;</span> <span class="s1">&#39;{if ($2 ==1) print $1 &gt; &quot;down.txt&quot;; else if($2 == 6) print $1 &gt; &quot;delete.txt&quot;; else print $1 &gt; &quot;other.txt&quot;}&#39;</span> xxx.log
</span></code></pre></td></tr></table></div></figure>


<h2>Share</h2>

<p><strong>主要负载均衡算法</strong></p>

<p>分布式场景下client 访问 server 的策略有很多，典型的有 轮询，随机，Hash，最少连接，响应速度，加权算法等。</p>

<p><strong>轮询算法</strong>：将所有请求，依次分发到每台服务器上。缺点: 所有机器的请求一样， 处理能力慢的机器压力变大。
<strong>随机算法</strong>：请求随机分配到各个服务器。简单。缺点：理论上所有机器的请求一样，处理能力慢的机器压力变大。
<strong>最少连接</strong>：将请求分配到连接数最少的服务器（目前处理请求最少的服务器）。优点：根据服务器当前的请求处理情况，动态分配。缺点: 实现比较复杂，需要感知服务器的状态
<strong>Hash</strong> : 根据IP地址进行Hash计算，得到IP地址。优点： 将来自同一IP地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。缺点：机器变化时会需要重新计算，最坏情况下所有请求都需要变化。
加权算法：在轮询，随机，最少链接，Hash’等算法的基础上，通过加权的方式，进行负载服务器分配。优点：根据权重，调节转发服务器的请求数目；缺点：使用相对复杂；
<strong>一致性 Hash</strong> ：一致性Hash 的实现是将 node 映射到一个 固定长度的圆环上，请求计算出Hash值按照预定的规则（一般是按照顺时钟方向）落到最近的服务器上。这样当出现机器的变化时，只会影响受影响机器与该机器反方向最近有效服务器之间的节点。其他的节点不会收到影响。当新增node时，只需要计算出该node的hash地址，然后将node 添加到 环的对应位置，只有新node 与后一个node之间的数据会受到影响。这种设计下的扩展性和容错性都比较好。比较不好的问题是在服务器比较少的情况下容易出现负责不均和的情况下。</p>

<p>一致性Hash 的实现是将 node 映射到一个 固定长度的圆环上，并在有效节点中引入多个虚节点（每个虚节点都是有效的的一个影子）。这个所有请求能够均匀的落到node上。</p>

<p>在现在的一致性hash实现上，Google 的研究人员发现在多次负载均衡过后不能够获得最优的负载均衡的效果，开发一个带负载因子(a)的一致性hash算法。</p>

<p>这个算法的能够保证一致性和负责的均衡性（所有的机器的load 都是平均load 的 （1+a）倍）。当出现机器的新增和删除后，通过节点移动的操作重新使得负载重新达到均衡，而这个移动的次数只跟负载因子(a)相关，而与实际节点数的多少无关。每个新增或者删除节点的动作只会导致  O(1/a2) 次其他节点的移动。</p>

<p>更多一致性Hash参考 : <a href="https://juejin.im/post/5b8f93576fb9a05d11175b8d">一致性Hash在负载均衡中的应用</a> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arts-week-three]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/04/08/arts-week-three/"/>
    <updated>2019-04-08T00:00:13+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/04/08/arts-week-three</id>
    <content type="html"><![CDATA[<h1>Algorithm</h1>

<p>本周完成的算法题: <a href="https://leetcode.com/problems/combination-sum/">Combination Sum</a></p>

<p>题目要求:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>给定一个不重复的数组(candidates)，以及一个目标(target)，从candidates找到所有的不重复的组合使得他们的和等于target。
</span><span class='line'>
</span><span class='line'>Note:
</span><span class='line'>1. 所有的数字都是正整数
</span><span class='line'>2. 同一个数字可以无限次的重复使用</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p><strong>分析:</strong></p>

<p>这题可以通过回溯法来解决，通过递归下降多次遍历数组来寻找满足条件的组合。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CombinationSum</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">lists</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">8</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</span><span class='line'>        <span class="n">stack</span><span class="o">.</span><span class="na">ensureCapacity</span><span class="o">(</span><span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</span><span class='line'>        <span class="n">calc</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span><span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;(),</span> <span class="n">lists</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">lists</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 递归下降深度优先遍历。 算法复杂度 O((n^2 + n) / 2)</span>
</span><span class='line'><span class="cm">     * 最终结果是 6ms  beats 92%</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * 分析了排在更前面的实现，发现主要的差异就是他们用List替代了Stack</span>
</span><span class='line'><span class="cm">     * 来保存中间状态，这样可以减少一个subList的操作。基本上可以到2ms</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @param candidates</span>
</span><span class='line'><span class="cm">     * @param target</span>
</span><span class='line'><span class="cm">     * @param start</span>
</span><span class='line'><span class="cm">     * @param stack         需要使用栈来保存中间状态。</span>
</span><span class='line'><span class="cm">     * @param lists</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">lists</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
</span><span class='line'>                <span class="k">continue</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>            <span class="k">if</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
</span><span class='line'>                <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span><span class='line'>                <span class="n">l</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()));</span>
</span><span class='line'>                <span class="n">lists</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span><span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">calc</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span> <span class="o">,</span><span class="n">stack</span> <span class="o">,</span> <span class="n">lists</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>Review</h1>

<p>本周Review <a href="https://medium.com/netflix-techblog/building-and-scaling-data-lineage-at-netflix-to-improve-data-infrastructure-reliability-and-1a52526a7977">Building and Scaling Data Lineage at Netflix to Improve Data Infrastructure Reliability, and Efficiency</a></p>

<p>本文是Netflix的一篇技术文章。讲述了Netflix内部是如何构建一个数据链路关系系统的。</p>

<p>公司从小到大的过程中，一定会伴随着数据越来越多，数据链路越来越复杂。很快就没有人能够了解数据全貌了。文章开篇提了三个场景:</p>

<ul>
<li>假设你是一个决策者，当你要根据数据看报做一个关键决策时，是否可以自己去验证下看报背后的数据到底是什么</li>
<li>假设你是一个开发者，当你决定要修改你提供的服务的数据结构时，是否可以知道哪些下游会受到影响</li>
<li>假设你现在负责平台的可靠性，你的任务是主动监测上游任务的问题，提前给数据作业owner报警。你要设计一个SLA预警系统，需要用到上下游数据依赖以及历史状态数据。<code>(Finally, imagine yourself in the role of a data platform reliability engineer tasked with providing advanced lead time to data pipeline (ETL) owners by proactively identifying issues upstream to their ETL jobs. You are designing a learning system to forecast Service Level Agreement (SLA) violations and would want to factor in all upstream dependencies and corresponding historical states)</code></li>
</ul>


<p>要满足以上的需求，就需要有一个 <code>complete and accurate data lineage system</code>。</p>

<p>自由和责任是Netflix内部文化的重要部分。核心思想是你可以自由的选择实现方式，但是要为其负责。同样这样的自由也会导致公司内部技术栈的多样性，同样也会带来更多的负责度。作者就面临这样的问题。以下是Netflix 的一个<code>Data Landscape</code>。</p>

<p><img src="https://cdn-images-1.medium.com/max/1400/0*gYI3uCywVhSrcoRo" alt="Data Landscape" /></p>

<p>为了满足Netflix内部多样化的数据，<code>Data Lineage</code>有以下的几个设计原则：</p>

<ul>
<li><code>Ensure data integrity</code> 数据完整性。 需要精确完整的保存数据关系来建立用户的信心。一个不完全可行系统带来伤害可能多过好处。</li>
<li><code>Enable seamless intergration</code> 无缝接入。需要能够满足新的数据工具快速接入。</li>
<li><code>Design a flexible data model</code> 灵活的数据结构。使用一个通用灵活的数据模型来表示不同的数据来源。</li>
</ul>


<p>最终的系统实现图如下：</p>

<p><img src="https://cdn-images-1.medium.com/max/2600/0*Xp1KHPFm1R7GZGAI" alt="系统实现图" /></p>

<p>解释下这个图：</p>

<p>首先左侧是数据接入层，每个业务系统都有它自己独立数据处理逻辑，独立的数据模型。所以在使用之前需要统一进行转换。</p>

<p>中间一层就是数据转换层，转换层将所有收集上来的数据进行转换，统一用点和边的图模式表达。数据转换完毕后会将数据存储到图数据库中。</p>

<p>右侧就是数据存储和服务层。在数据之上建立了的REST服务层，对外提供数据服务。</p>

<h1>Tip</h1>

<p>在Java中很多情况需要对一些特殊字符做一些转义。那么一般的写法就是为罗列出所有的需要进行替换的字符，然后不停的调用replace。比如像下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="n">keyword</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;\\&quot;</span><span class="o">,</span> <span class="s">&quot;\\\\&quot;</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="s">&quot;\\*&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="s">&quot;\\+&quot;</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;|&quot;</span><span class="o">,</span> <span class="s">&quot;\\|&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;{&quot;</span><span class="o">,</span> <span class="s">&quot;\\{&quot;</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;}&quot;</span><span class="o">,</span> <span class="s">&quot;\\}&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;(&quot;</span><span class="o">,</span> <span class="s">&quot;\\(&quot;</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;)&quot;</span><span class="o">,</span> <span class="s">&quot;\\)&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;^&quot;</span><span class="o">,</span> <span class="s">&quot;\\^&quot;</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;$&quot;</span><span class="o">,</span> <span class="s">&quot;\\$&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;[&quot;</span><span class="o">,</span> <span class="s">&quot;\\[&quot;</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;]&quot;</span><span class="o">,</span> <span class="s">&quot;\\]&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;?&quot;</span><span class="o">,</span> <span class="s">&quot;\\?&quot;</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">,</span> <span class="s">&quot;\\,&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">,</span> <span class="s">&quot;\\.&quot;</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;&amp;&quot;</span><span class="o">,</span> <span class="s">&quot;\\&amp;&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="s">&quot;\\-&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样写虽然能够完成需求，但是不太优雅。在Java的正则表达式中实际是可以支持类似<code>$0 $1</code>这样的占位符的。那么像<code>.replace("[", "\\[")</code> 可以改写成 <code>.replace("[", "\\$0")</code>。</p>

<p>在这个实现中，<code>$0</code> 代表的是整个正则的匹配结果，<code>$1 $2...$n</code> 代表的是从1-n的捕获组的内容。</p>

<p>具体的捕获组的介绍可以参考：<a href="https://blog.csdn.net/just4you/article/details/70767928">正则表达式的捕获组(capture group)在Java中的使用</a></p>

<p>上面的语句改成类似形式的案例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;\\*+|{}^$[]?,.&amp;-&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">&quot;[\\\\\\*\\+\\|\\{\\}\\(\\)\\^\\$\\[\\]\\?\\,\\.\\&amp;\\-]&quot;</span><span class="o">,</span> <span class="s">&quot;\\\\$0&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//输出</span>
</span><span class='line'><span class="err">\</span><span class="o">*+|{}^</span><span class="n">$</span><span class="o">[]?,.&amp;-</span>
</span><span class='line'><span class="err">\\\</span><span class="o">*</span><span class="err">\</span><span class="o">+</span><span class="err">\</span><span class="o">|</span><span class="err">\</span><span class="o">{</span><span class="err">\</span><span class="o">}</span><span class="err">\</span><span class="o">^</span><span class="err">\</span><span class="n">$</span><span class="err">\</span><span class="o">[</span><span class="err">\</span><span class="o">]</span><span class="err">\</span><span class="o">?</span><span class="err">\</span><span class="o">,</span><span class="err">\</span><span class="o">.</span><span class="err">\</span><span class="o">&amp;</span><span class="err">\</span><span class="o">-</span>
</span></code></pre></td></tr></table></div></figure>


<h1>Share</h1>

<p><a href="http://linuxlsx.top/blog/2019/04/07/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-fu-zhi-suan-fa/">GC算法-复制算法</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[垃圾回收的算法与实现读书笔记-复制算法]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/04/07/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-fu-zhi-suan-fa/"/>
    <updated>2019-04-07T22:59:17+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/04/07/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-fu-zhi-suan-fa</id>
    <content type="html"><![CDATA[<p>在<a href="http://linuxlsx.top/blog/2019/03/26/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-yin-yong-ji-shu-fa/">上一篇文章</a>中介绍了<code>引用计数法</code>的实现，这边接着来讲<code>复制算法</code>的实现</p>

<p>文中部分图片引用自《垃圾回收的算法与实现》一书，如有版权问题，请联系删除。</p>

<h1>复制算法</h1>

<p>GC复制算法是<code>Marvin L. Minsky</code>在1963年研究出来的算法。该算法会将整个堆分成两个区域：<code>from area</code> 和 <code>to area</code>。这两个空间的大小一样。GC复制算法利用from区做分配，当from区满了以后，会将存活的对象全部复制到to区，当复制完成以后会将from区和to区互换，这样整体的GC也就结束了。下图描述了整体的一个概要:</p>

<p><img src="https://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E5%A4%8D%E5%88%B6%E6%A6%82%E8%A6%81.png?x-oss-process=style/black" alt="复制算法概要" /></p>

<!-- more -->


<h2>算法实现</h2>

<p>用Java来模拟复制算法有个难点是：因为Java的参数是值传递，所以在复制对象的时候需要更新原来对象的引用，但是这个不引入辅助的情况下是比较难的。所以我们先来通过图解了解下整个GC算法的一个过程。</p>

<p>首先假设现在堆中对象结构如下图所示：</p>

<p><img src="https://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E5%A4%8D%E5%88%B6%E7%AC%AC%E4%B8%80%E6%AD%A5.png?x-oss-process=style/black" alt="初始状态" /></p>

<p>根引用<strong>A</strong>，<strong>A</strong>同时引用了<strong>C</strong>和<strong>D</strong>，<strong>B</strong>没有引用来源，所以是需要被回收的对象。复制算法的回收是从根开始的，所有能够从根到达的对象都是活的对象，需要被复制。</p>

<p>首先对象A被复制，生成了<strong>A'</strong>。因为<strong>A</strong>有引用其他的对象，所以新生成的<strong>A'</strong>也会引用到这些对象。但是需要注意的是这些对象现在都还在from区域，所以<strong>A'</strong>持有指向from区域的引用，如下图所示：</p>

<p><img src="https://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E5%A4%8D%E5%88%B6%E7%AC%AC%E4%BA%8C%E6%AD%A5.png?x-oss-process=style/black" alt="复制A" /></p>

<p>接着会将<strong>A</strong>对象标记为<code>COPIED</code>，如下图所示：</p>

<p><img src="https://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E5%A4%8D%E5%88%B6%E7%AC%AC%E4%B8%89%E6%AD%A5.png?x-oss-process=style/black" alt="复制A第二步" /></p>

<p>接着会把<strong>A</strong>引用的对象<strong>C</strong>和<strong>D</strong>都copy到to区域，同时原对象都标记为<code>COPIED</code>。同时将根的引用切换到<strong>A'</strong>，变成了如下图所示的情况：</p>

<p><img src="https://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E5%A4%8D%E5%88%B6%E7%AC%AC%E5%9B%9B%E6%AD%A5.png?x-oss-process=style/black" alt="复制A的子对象" /></p>

<p>最后将from区里面的对象全部清理掉，并将from和to区域交换，就完成了一次GC的过程。</p>

<p><img src="https://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E5%A4%8D%E5%88%B6%E7%AC%AC%E4%BA%94%E6%AD%A5.png?x-oss-process=style/black" alt="完成GC" /></p>

<h3>代码模拟实现</h3>

<p>首先对于<code>Obj</code>对象需要增加一个<code>copied</code>的标记来方式对象被重复的复制。</p>

<p>GC复制算法使用的堆对象比前面提到的<code>标记-清除</code>和<code>引用计数</code>都简单，因为在内存中都是连续分配的，所以也不需要指定分配策略。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CopyHeap</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * from 区域的起始位置。在完成一个copying后，</span>
</span><span class='line'><span class="cm">     * fromStart 和 toStart的值会进行互换</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="n">fromStart</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * to 区域的起始位置。</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="n">toStart</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 表明当前空闲内存的起始位置。</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="n">free</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 表明实际可用的大小</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">CopyHeap</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 因为Copy算法是连续分配的，所以不需要确定分配策略</span>
</span><span class='line'><span class="cm">     * @param size</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">CopyHeap</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">realSize</span> <span class="o">=</span> <span class="n">calcPowSize</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">realSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'>        <span class="n">fromStart</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="n">toStart</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
</span><span class='line'>        <span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 将数据Copy 到 TO 区块。简单的实现为增加空闲内存的起始位置</span>
</span><span class='line'><span class="cm">     * @param size</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">copyData</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">free</span><span class="o">;</span>
</span><span class='line'>        <span class="n">free</span> <span class="o">+=</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">start</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 判断是否有足够的内存来满足对象分配</span>
</span><span class='line'><span class="cm">     * @param size</span>
</span><span class='line'><span class="cm">     * @return</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasEnoughMemory</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">free</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">+</span> <span class="n">fromStart</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 每次copying完成以后，互换fromStart 和 toStart</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(){</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">fromStart</span><span class="o">;</span>
</span><span class='line'>        <span class="n">fromStart</span> <span class="o">=</span> <span class="n">toStart</span><span class="o">;</span>
</span><span class='line'>        <span class="n">toStart</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">calcPowSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span><span class="o">;</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">8</span><span class="o">;</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>GC复制算法本身实现也比较简单，主要注意的地方就是要考虑Java的值传递的问题，所以在实现的时候做了一个小的改造，就是只是将原对象的起始地址修改下，以此来表示对象已经被复制了。否则要在Java中实现引用传递还是比较麻烦的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CopyAlgo</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">CopyHeap</span> <span class="n">heap</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 表示GC 的根</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">CopyObj</span><span class="o">&gt;</span> <span class="n">roots</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">CopyAlgo</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">CopyHeap</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 创建对象</span>
</span><span class='line'><span class="cm">     * @param size</span>
</span><span class='line'><span class="cm">     * @return</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">CopyObj</span> <span class="nf">newObj</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">heap</span><span class="o">.</span><span class="na">hasEnoughMemory</span><span class="o">(</span><span class="n">size</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">copying</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">heap</span><span class="o">.</span><span class="na">hasEnoughMemory</span><span class="o">(</span><span class="n">size</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;Copy GC Fail Heap total(%d) used(%d)&quot;</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">free</span><span class="o">));</span>
</span><span class='line'>                <span class="k">throw</span> <span class="k">new</span> <span class="nf">OutOfMemoryError</span><span class="o">(</span><span class="s">&quot;------ oh, out of memory! ------&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CopyObj</span> <span class="n">copyObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">CopyObj</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">free</span><span class="o">);</span>
</span><span class='line'>        <span class="n">heap</span><span class="o">.</span><span class="na">free</span> <span class="o">+=</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">copyObj</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 开始进行复制</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">copying</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">oldSize</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">free</span> <span class="o">-</span> <span class="n">heap</span><span class="o">.</span><span class="na">fromStart</span><span class="o">;</span>
</span><span class='line'>        <span class="c1">//将当前空闲内存的起始位置置为to区域的起始位置</span>
</span><span class='line'>        <span class="n">heap</span><span class="o">.</span><span class="na">free</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">toStart</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//从根节点开始递归的进行复制</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">CopyObj</span> <span class="n">root</span> <span class="o">:</span> <span class="n">roots</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">copy</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//交互from 和 to</span>
</span><span class='line'>        <span class="n">heap</span><span class="o">.</span><span class="na">swap</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;Copy GC End. Heap before(%d) now(%d)&quot;</span><span class="o">,</span> <span class="n">oldSize</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">free</span> <span class="o">-</span> <span class="n">heap</span><span class="o">.</span><span class="na">fromStart</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="n">CopyObj</span> <span class="n">copyObj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//复制对象，在目标区域中申请同样大小的内存</span>
</span><span class='line'>        <span class="n">copyData</span><span class="o">(</span><span class="n">copyObj</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//将复制标记为置为true</span>
</span><span class='line'>        <span class="n">copyObj</span><span class="o">.</span><span class="na">copied</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//开始复制引用的对象</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">copyObj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">CopyObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">(</span><span class="n">CopyObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>            <span class="n">copy</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">copyData</span><span class="o">(</span><span class="n">CopyObj</span> <span class="n">copyObj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//因为Java的参数传递均为值传递，所以为了不影响上层的使用</span>
</span><span class='line'>        <span class="c1">//这里均实现为修改对象的起始位置。</span>
</span><span class='line'>        <span class="n">copyObj</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">copyData</span><span class="o">(</span><span class="n">copyObj</span><span class="o">.</span><span class="na">size</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 把对象置为根节点</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @param obj 根对象</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeItToRoot</span><span class="o">(</span><span class="n">CopyObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">roots</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeFromRoot</span><span class="o">(</span><span class="n">CopyObj</span> <span class="n">obj</span><span class="o">){</span>
</span><span class='line'>        <span class="n">roots</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后看一个实例:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GcUseCaseByCopyAlgo</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CopyAlgo</span> <span class="n">copyAlgo</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">CopyAlgo</span><span class="o">(</span><span class="mi">32</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CopyObj</span> <span class="n">first</span> <span class="o">=</span> <span class="n">copyAlgo</span><span class="o">.</span><span class="na">newObj</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
</span><span class='line'>        <span class="n">CopyObj</span> <span class="n">second</span> <span class="o">=</span> <span class="n">copyAlgo</span><span class="o">.</span><span class="na">newObj</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">copyAlgo</span><span class="o">.</span><span class="na">makeItToRoot</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
</span><span class='line'>        <span class="n">copyAlgo</span><span class="o">.</span><span class="na">makeItToRoot</span><span class="o">(</span><span class="n">second</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CopyObj</span> <span class="n">firstChildOne</span> <span class="o">=</span> <span class="n">copyAlgo</span><span class="o">.</span><span class="na">newObj</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//进行到这里时需要的总内存为 13 + 7， 总内存只有16， 所有会进行一次复制</span>
</span><span class='line'>        <span class="c1">//回收掉没有引用来源的 firstChildOne</span>
</span><span class='line'>        <span class="n">CopyObj</span> <span class="n">firstChildTwo</span> <span class="o">=</span> <span class="n">copyAlgo</span><span class="o">.</span><span class="na">newObj</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">first</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">firstChildTwo</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//到这里需要的内存为 4+4+7+6 = 21, 大于总内存 16，会进行一次copy ,</span>
</span><span class='line'>        <span class="c1">//但是仍然是不能满足要求的，所以会抛出OOM的异常</span>
</span><span class='line'>        <span class="n">CopyObj</span> <span class="n">firstChildChildOne</span> <span class="o">=</span> <span class="n">copyAlgo</span><span class="o">.</span><span class="na">newObj</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
</span><span class='line'>        <span class="n">firstChildTwo</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">firstChildChildOne</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        <span class="n">CopyObj</span> <span class="n">secondChild</span> <span class="o">=</span> <span class="n">copyAlgo</span><span class="o">.</span><span class="na">newObj</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
</span><span class='line'>        <span class="n">second</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">secondChild</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">firstChildOne</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">firstChildChildOne</span><span class="o">);</span>
</span><span class='line'>        <span class="n">first</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">firstChildTwo</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CopyObj</span> <span class="n">needCopyingObj</span> <span class="o">=</span> <span class="n">copyAlgo</span><span class="o">.</span><span class="na">newObj</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果如下图所示:</p>

<p><img src="https://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg?x-oss-process=style/origin" alt="运行结果" /></p>

<h2>算法优缺点</h2>

<p>优点:</p>

<pre><code>* 吞吐量较好。GC复制算法只会搜索存活的对象，跟标记-清除算法比需要的时间较短。
* 可实现高速分配。GC算法的分配是在一片连续的内存空间分配的，所以只需要移动空闲的指针即可。
* 不会产生碎片。
* 对缓存友好。每次GC完成以后，有关联的对象都会顺序排列在一起。
</code></pre>

<p>缺点:</p>

<pre><code>* 堆的使用效率低下。很明显，只能使用一般的堆
* 递归调用函数。每次复制对象都要递归的调用函数，效率比较低，还有栈溢出的可能性。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arts-week-two]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/03/29/arts-week-two/"/>
    <updated>2019-03-29T21:25:12+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/03/29/arts-week-two</id>
    <content type="html"><![CDATA[<h1>ARTS 第2周</h1>

<h2>Algorithm</h2>

<p>本周完成的算法题: <a href="https://leetcode.com/problems/valid-sudoku/">Valid Sudoku</a></p>

<p>题目要求:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>通过二维数组定义了9x9的数独库，这个数独库的某些位置会被数字填充，其他地方填充'.'，现在需要你来验证这个数独库是否合法的。有效数独的规则如下:
</span><span class='line'>
</span><span class='line'>1. 每一行都是1-9不重复的数字
</span><span class='line'>2. 每一列都是1-9不重复的数字
</span><span class='line'>3. 每一个3x3的小方格中也是1-9不重复的数字</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p><strong>分析:</strong></p>

<p>要完成有效性的判定，双重循环遍历是肯定要的。我们需要考虑的是如何只使用双重循环就把所有事情搞定。通过对矩阵的观察，我们发现有以下的规律:</p>

<ul>
<li>当我们访问<code>soduku[i][j]</code>，通过转换顺序<code>soduku[j][i]</code>，这样可以同时访问一行、一列。</li>
<li>可以通过 <code>(i / 3) 和 (j / 3)</code>得到一个<code>3x3</code>小方格，同时通过<code>(i % 3) * 3 + j % 3</code>计算出<code>sudoku[i][j]</code>在小方格中的位置。</li>
</ul>


<p>通过以上两个规律，我们就可以在<code>n * n</code>次循环中得出是否合法的结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidSudoku</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//实现的比较挫，这里定了9个数组用来代表9个 3x3的小方格</span>
</span><span class='line'>        <span class="kt">char</span><span class="o">[]</span> <span class="n">rect0</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">char</span><span class="o">[]</span> <span class="n">rect1</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">char</span><span class="o">[]</span> <span class="n">rect2</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">char</span><span class="o">[]</span> <span class="n">rect3</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">char</span><span class="o">[]</span> <span class="n">rect4</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">char</span><span class="o">[]</span> <span class="n">rect5</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">char</span><span class="o">[]</span> <span class="n">rect6</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">char</span><span class="o">[]</span> <span class="n">rect7</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">char</span><span class="o">[]</span> <span class="n">rect8</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="kt">char</span><span class="o">[]&gt;</span> <span class="n">maps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span><span class='line'>        <span class="n">maps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;0_0&quot;</span><span class="o">,</span> <span class="n">rect0</span><span class="o">);</span>
</span><span class='line'>        <span class="n">maps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;0_1&quot;</span><span class="o">,</span> <span class="n">rect1</span><span class="o">);</span>
</span><span class='line'>        <span class="n">maps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;0_2&quot;</span><span class="o">,</span> <span class="n">rect2</span><span class="o">);</span>
</span><span class='line'>        <span class="n">maps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;1_0&quot;</span><span class="o">,</span> <span class="n">rect3</span><span class="o">);</span>
</span><span class='line'>        <span class="n">maps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;1_1&quot;</span><span class="o">,</span> <span class="n">rect4</span><span class="o">);</span>
</span><span class='line'>        <span class="n">maps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;1_2&quot;</span><span class="o">,</span> <span class="n">rect5</span><span class="o">);</span>
</span><span class='line'>        <span class="n">maps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;2_0&quot;</span><span class="o">,</span> <span class="n">rect6</span><span class="o">);</span>
</span><span class='line'>        <span class="n">maps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;2_1&quot;</span><span class="o">,</span> <span class="n">rect7</span><span class="o">);</span>
</span><span class='line'>        <span class="n">maps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;2_2&quot;</span><span class="o">,</span> <span class="n">rect8</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">char</span><span class="o">[]</span> <span class="n">hor_array</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>            <span class="kt">char</span><span class="o">[]</span> <span class="n">ver_array</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">,</span><span class="sc">&#39;.&#39;</span><span class="o">};</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>                <span class="c1">//行</span>
</span><span class='line'>                <span class="kt">char</span> <span class="n">hor_char</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
</span><span class='line'>                <span class="c1">//列</span>
</span><span class='line'>                <span class="kt">char</span> <span class="n">ver_char</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>                <span class="c1">//如果第一次出现，则把对应的位置替换为对应的内容</span>
</span><span class='line'>                <span class="c1">//如果第二次出现，那么内容就不是初始值了，可以认定是invalid</span>
</span><span class='line'>                <span class="k">if</span><span class="o">(</span><span class="n">hor_char</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span><span class="o">){</span>
</span><span class='line'>                    <span class="k">if</span><span class="o">(</span><span class="n">hor_array</span><span class="o">[</span><span class="n">hor_char</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">){</span>
</span><span class='line'>                        <span class="n">hor_array</span><span class="o">[</span><span class="n">hor_char</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="n">hor_char</span><span class="o">;</span>
</span><span class='line'>                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>                    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">//计算当前位置所属的小方格</span>
</span><span class='line'>                    <span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="o">(</span><span class="n">j</span> <span class="o">/</span> <span class="mi">3</span><span class="o">);</span>
</span><span class='line'>                    <span class="c1">//int index = (i % 3) * 3 + j % 3;</span>
</span><span class='line'>                    <span class="kt">char</span><span class="o">[]</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">maps</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>                    <span class="k">if</span> <span class="o">(</span><span class="n">rect</span><span class="o">[</span><span class="n">hor_char</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                        <span class="n">rect</span><span class="o">[</span><span class="n">hor_char</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="n">hor_char</span><span class="o">;</span>
</span><span class='line'>                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>                    <span class="o">}</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">if</span><span class="o">(</span><span class="n">ver_char</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span><span class="o">){</span>
</span><span class='line'>                    <span class="k">if</span><span class="o">(</span><span class="n">ver_array</span><span class="o">[</span><span class="n">ver_char</span> <span class="o">-</span> <span class="mi">49</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">){</span>
</span><span class='line'>                        <span class="n">ver_array</span><span class="o">[</span><span class="n">ver_char</span> <span class="o">-</span> <span class="mi">49</span><span class="o">]</span> <span class="o">=</span> <span class="n">ver_char</span><span class="o">;</span>
</span><span class='line'>                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>                    <span class="o">}</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实现思路上算是正确的，但不是最优的哈。最优代码参考:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 最快的版本。 10ms  beats 100%。</span>
</span><span class='line'><span class="cm"> * 对于每个横、竖和3x3 进行 `|` 操作，这样通过 `&amp;`操作就能知道这个数字是否重复过。</span>
</span><span class='line'><span class="cm"> * @param board</span>
</span><span class='line'><span class="cm"> * @return</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidSudokuFastest</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="o">[]</span> <span class="n">vset</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="o">[</span><span class="mi">9</span><span class="o">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">[]</span> <span class="n">hset</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="o">[</span><span class="mi">9</span><span class="o">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">[]</span> <span class="n">bckt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="o">[</span><span class="mi">9</span><span class="o">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">)</span> <span class="o">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">((</span><span class="n">hset</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;</span> <span class="n">idx</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
</span><span class='line'>                        <span class="o">(</span><span class="n">vset</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;</span> <span class="n">idx</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
</span><span class='line'>                        <span class="o">(</span><span class="n">bckt</span><span class="o">[(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">j</span> <span class="o">/</span> <span class="mi">3</span><span class="o">]</span> <span class="o">&amp;</span> <span class="n">idx</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>                <span class="n">hset</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">|=</span> <span class="n">idx</span><span class="o">;</span>
</span><span class='line'>                <span class="n">vset</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">|=</span> <span class="n">idx</span><span class="o">;</span>
</span><span class='line'>                <span class="n">bckt</span><span class="o">[(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">j</span> <span class="o">/</span> <span class="mi">3</span><span class="o">]</span> <span class="o">|=</span> <span class="n">idx</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Review</h2>

<p>本周Review <a href="https://medium.com/s/story/the-law-of-two-thirds-cfad7c4d42eb">A Technique for Deciding When to Say No</a></p>

<p><code>人不能完成所有事情，所以我们需要对要做的事情，想要的东西做取舍。当你选择某些项的时候，也就舍弃了其他的</code></p>

<p>文章中提出了一个<code>2-3</code>法则，就是说在3个关键要素中，你只能同时选择两个。比如：质量、速度和价格，只能选择两个。如果你想要质量和速度，那么价格必然就贵；你想要低价同时也想保持质量，那么速度必然受到影响；你想要低价和速度，那么质量就无法保证。</p>

<p>这个观点和我们程序员熟悉的<code>CAP</code>理论有异曲同工之妙，同样的三个要素，不可兼得。</p>

<p>那么怎么样来进行选择呢？那么首先要弄明白的是你想要的到底是什么？这里要记住：<code>你是不可能做所有事情，得到所有东西的</code>。</p>

<p>对于生活，一定不要让自己时时处于忙碌的状态，忙碌意味着你不知道你想要的是什么，你不知道对什么说<strong>不</strong>，所以你的时间被无关的事情给占有了。</p>

<h2>Tip</h2>

<p><strong>在数据量大的情况下，任何系统的性能隐患都被放大直到系统崩溃。</strong></p>

<p>在本周有一个算法同学写了一段类似如下的大数据处理SQL：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='SQL'><span class='line'><span class="k">select</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="n">process</span><span class="p">(</span><span class="n">col4</span><span class="p">,</span> <span class="k">map</span><span class="p">(</span><span class="s1">&#39;{1,2,3,4,5}&#39;</span><span class="p">))</span> <span class="k">from</span> <span class="n">table_a</span>
</span></code></pre></td></tr></table></div></figure>


<p>SQL 很简单，<code>process</code> 和 <code>map</code>都是自定的函数。其中<code>map</code>函数会将参数转化成一个map结构。但是在实际运行的时候发现性能很差，100亿条数据执行了9个多小时。他找我帮他看看问题在哪里？</p>

<p>问题其实就是<code>map</code>函数导致的，这个sql每处理一条数据就会调用<code>map</code>函数，就会创建一个新对象。同时因为参数比较长，会多次触发map的扩容，导致整个SQL执行99%以上的时间其实在创建map和扩容中。</p>

<p>当修改实现改成使用缓存以后，性能溜得飞起，只要了<strong>4分钟</strong>就完成了。</p>

<p>在大数据环境下，对象的创建其实是很昂贵的操作。所以像<code>Hadoop</code>这样的大数据框架才会设计成对象复用。</p>

<h2>Share</h2>

<p><a href="http://linuxlsx.top/blog/2019/03/26/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-yin-yong-ji-shu-fa/">GC算法-引用计数法</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[垃圾回收的算法与实现读书笔记-引用计数法]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/03/26/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-yin-yong-ji-shu-fa/"/>
    <updated>2019-03-26T17:19:43+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/03/26/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-yin-yong-ji-shu-fa</id>
    <content type="html"><![CDATA[<p>在<a href="http://linuxlsx.top/blog/2017/12/28/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-biao-ji-zheng-li-suan-fa/">上一篇文章</a>中介绍了<code>标记-清除法</code>的实现，这边接着来讲<code>引用计数法</code>的实现</p>

<p>文中部分图片引用自《垃圾回收的算法与实现》一书，如有版权问题，请联系删除。</p>

<h1>引用计数法</h1>

<p><code>引用计数法</code>是George E.Colins 在1960年提出来的。主要思想是:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="err">让每个对象都记录下被多个其他对象引用的数量，当没有其他对象引用时，就可以让该对象被回收。</span>
</span></code></pre></td></tr></table></div></figure>


<p>引用计数算法理解起来比较简单。首先来看下伪代码</p>

<!-- more -->


<h2>伪代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="c1">//分配对象</span>
</span><span class='line'><span class="n">new_obj</span><span class="p">(</span><span class="n">size</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//向堆请求内存分配</span>
</span><span class='line'>    <span class="n">obj</span> <span class="o">=</span> <span class="n">pickup_chunk</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="err">$</span><span class="n">free_list</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>        <span class="c1">//如果请求失败的话，直接失败</span>
</span><span class='line'>        <span class="n">allocation_fail</span><span class="p">()</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="c1">//设置初始的引用计数为 1</span>
</span><span class='line'>        <span class="n">obj</span><span class="p">.</span><span class="n">ref_cnt</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">//引用变化时更新引用计数 ptr-&gt;obj</span>
</span><span class='line'><span class="n">update_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">obj</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">//增加obj的计数</span>
</span><span class='line'>    <span class="n">inc_ref_cnt</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span><span class='line'>    <span class="c1">//减少原对象的计数</span>
</span><span class='line'>    <span class="n">dec_ref_cnt</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
</span><span class='line'>    <span class="c1">//更新引用</span>
</span><span class='line'>    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">obj</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//增加对象的引用计数</span>
</span><span class='line'><span class="n">inc_ref_cnt</span><span class="p">(</span><span class="n">obj</span><span class="p">){</span>
</span><span class='line'>    <span class="n">obj</span><span class="p">.</span><span class="n">ref_cnt</span><span class="o">++</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//减少对象的引用计数，在这里进行回收</span>
</span><span class='line'><span class="n">def_ref_cnt</span><span class="p">(</span><span class="n">obj</span><span class="p">){</span>
</span><span class='line'>    <span class="n">obj</span><span class="p">.</span><span class="n">ref_cnt</span><span class="o">--</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">ref_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="c1">//当对象的引用计数为0时，遍历所有引用的对象，并将它们的计数减 1</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="nl">child</span> <span class="p">:</span> <span class="n">children</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</span><span class='line'>            <span class="n">def_ref_cnt</span><span class="p">(</span><span class="o">*</span><span class="n">child</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//释放对象，回收内存</span>
</span><span class='line'>        <span class="n">reclaim</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>更新对象计数时需要先增加目标对象的计数，然后再减少源对象的计数器。这样是为了防止目标对象和源对象是同一个对象时，先减少源对象计数器可能会导致对象计数器归零，被当成垃圾回收掉。</p>

<h2>数据结构</h2>

<p>为了实现引用计数法，需要在对象头中增加一个<code>引用计数器</code>。新的数据结构为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReferenceCountObj</span> <span class="kd">extends</span> <span class="n">Obj</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 表示该对象的引用计数</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Obj</code>对象的定义见<a href="http://linuxlsx.top/blog/2017/12/28/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-biao-ji-zheng-li-suan-fa/">标记-清除法</a></p>

<h2>算法实现</h2>

<p>引用计数算法中主要的处理在<code>update_ptr</code>函数。请看下图，初始状态从根引用<strong>A</strong>和<strong>C</strong>，从<strong>A</strong>引用<strong>B</strong>。<strong>A</strong>持有指向<strong>B</strong>的唯一指针，假设现在将该指针更新到<strong>C</strong>。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/update_ptr%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0.png?x-oss-process=style/black" alt="update_ptr" /></p>

<p>通过以上的更新，<strong>B</strong>的计数器值变成了<strong>0</strong>，因此<strong>B</strong>被回收了，且<strong>B</strong>连上了空闲列表，可以被重新利用。又因为新形成了由<strong>A</strong>指向<strong>C</strong>的指针，所以<strong>C</strong>的计数器的值增为<strong>2</strong>。</p>

<p>以下是具体的一个实现代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReferenceCountAlgo</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">Heap</span> <span class="n">heap</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ReferenceCountAlgo</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fitStrategy</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Heap</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">fitStrategy</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 表示GC 的根</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">ReferenceCountObj</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReferenceCountObj</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 表示已经分配过的对象列表</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">ReferenceCountObj</span><span class="o">&gt;</span> <span class="n">allocatedObjList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 创建一个新的对象</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @param size 对象的大小</span>
</span><span class='line'><span class="cm">     * @return 创建好的对象</span>
</span><span class='line'><span class="cm">     * @throws OutOfMemoryError 当内存无法满足分配要求时抛出</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">ReferenceCountObj</span> <span class="nf">newObj</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Slot</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">applySlot</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//对于引用计数法来说，如果slot 为空，说明内存已经耗尽了</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">slot</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">OutOfMemoryError</span><span class="o">(</span><span class="s">&quot;------ oh, out of memory! ------&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">initObj</span><span class="o">(</span><span class="n">slot</span><span class="o">);</span>
</span><span class='line'>        <span class="n">allocatedObjList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 建立对象之间的引用关系。 相当于 from = to</span>
</span><span class='line'><span class="cm">     * @param from      引用的起始对象。</span>
</span><span class='line'><span class="cm">     * @param to        应用的目标对象。该对象的引用计数需要加一</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reference</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">from</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">incrRefCount</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 删除对象之间的引用关系。相当于 from = null</span>
</span><span class='line'><span class="cm">     * @param from    引用 &#39;需要解除引用对象&#39; 的对象。 如果 from == null, 说明是要解除和根的引用</span>
</span><span class='line'><span class="cm">     * @param to      需要解除引用的对象。该对象的引用计数会减一</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deReference</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">from</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">to</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">from</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
</span><span class='line'>            <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">defRefCount</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 修改对象的引用关系。相当于从 from = oldTo 变化为 from = newTo</span>
</span><span class='line'><span class="cm">     * @param from</span>
</span><span class='line'><span class="cm">     * @param oldTo</span>
</span><span class='line'><span class="cm">     * @param newTo</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeReference</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">from</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">oldTo</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">newTo</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">oldTo</span><span class="o">);</span>
</span><span class='line'>        <span class="n">defRefCount</span><span class="o">(</span><span class="n">oldTo</span><span class="o">);</span>
</span><span class='line'>        <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newTo</span><span class="o">);</span>
</span><span class='line'>        <span class="n">incrRefCount</span><span class="o">(</span><span class="n">newTo</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">incrRefCount</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">defRefCount</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//如果对象的计数变为0，则直接进行回收操作</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">//循环遍历该对象引用的对象，对其进行引用减一操作</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">ReferenceCountObj</span> <span class="n">countObj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>                <span class="n">defRefCount</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">//释放掉内存</span>
</span><span class='line'>            <span class="n">heap</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="k">new</span> <span class="nf">Slot</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">start</span><span class="o">,</span> <span class="n">obj</span><span class="o">.</span><span class="na">size</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">ReferenceCountObj</span> <span class="nf">initObj</span><span class="o">(</span><span class="n">Slot</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReferenceCountObj</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">slot</span><span class="o">.</span><span class="na">start</span><span class="o">;</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">slot</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
</span><span class='line'>        <span class="c1">//对象的初始化引用计数为 0</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 把对象置为根节点</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @param obj 根对象</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeItToRoot</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>引用计数法的优点</h3>

<pre><code>* 当对象的计数器归零后可立刻回收
* 最大暂停时间短。在操作对象的时候同时进行垃圾回收，不需要专门的阶段来进行回收
* 回收只需要考虑当前对象及其所以引用的对象，不需要从根对象开始
</code></pre>

<h3>引用计数法的缺点</h3>

<pre><code>* 循环引用无法回收。
* 计数器会带来额外的读/写开销，频繁的写操作可能会导致高速缓存失效。所以引用计数法不适合通用的大容量、高性能的内存管理场景。
* 用于计数的计数器必须能够满足一个对象引用堆中所有其他对象的极端情况。所有计数器大小必须和引用类型一样大，会造成内存浪费。
* 在多线程环境中需要保证引用计数的增减以及加载和存储指针的操作都必须原子化。
</code></pre>

<h2>算法优化</h2>

<pre><code>1. 降低计数器带来的开销
   1.1 延迟计数法。将应用计数延迟某个阶段统一的执行
   1.2 合并计数法。不在每次变更都更新计数器，而是关注开始和结束状态，对中间的变更进行合并。
2. 解决循环引用无法回收的问题
   2.1 通过部分标记的方法解决循环引用的问题。
</code></pre>

<h3>延迟计数法</h3>

<p>在<code>延迟计数法</code>中，引入了一个新的结构ZCT(Zero Count Table)，来保存计数器归零的对象。相比原来的实现，有以下几个步骤需要进行调整。</p>

<p><strong>1. 创建对象</strong> 当对象内存分配失败时，要先遍历下ZCT释放内存，然后再次尝试申请内存，如果还是失败的话，就真的是内存不足了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="n">ReferenceCountObj</span> <span class="nf">newObj</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Slot</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">applySlot</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">//对于引用计数法来说，如果slot 为空</span>
</span><span class='line'>    <span class="c1">//不直接抛出OOM，而是释放掉ZCT中可以释放的对象</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">slot</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">scanZctToReleaseMemory</span><span class="o">();</span>
</span><span class='line'>        <span class="n">slot</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">applySlot</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">slot</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">OutOfMemoryError</span><span class="o">(</span><span class="s">&quot;------ oh, out of memory! ------&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">initObj</span><span class="o">(</span><span class="n">slot</span><span class="o">);</span>
</span><span class='line'>    <span class="n">allocatedObjList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>2. 计数器操作</strong> 当对象计数器的值降到<code>0</code>时，不要直接将对象回收，而是将对象添加到ZCT中。另外为了减少从根节点应用的对象的计数器频繁变更，规定当应用是来自根节点的时候，计数器不加<code>1</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'>   <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 模拟和根节点建立引用关系</span>
</span><span class='line'><span class="cm">     * @param obj 根对象</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeItToRoot</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//如果对象的应用是来自根节点，那么就不要修改对象的计数器</span>
</span><span class='line'>        <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//因为对象的计数器为0，所以将其放到ZCT中</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">isFull</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">scanZctToReleaseMemory</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">zct</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deReference</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">from</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//因为根节点引用的对象初始计数器为0，所以释放的时候不需要操作计数器</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">from</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
</span><span class='line'>            <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>            <span class="n">defRefCount</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 与原始实现不同，当计数器变成0时，将对象放到ZCT中而不是直接释放</span>
</span><span class='line'><span class="cm">     * @param obj</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">defRefCount</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//如果对象的计数变为0，则优先把对象放到zct中</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//如果队列满了，则释放掉队列中的对象</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">isFull</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">scanZctToReleaseMemory</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">zct</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>引入ZCT后，根节点引用的对象和计数器为0的对象同时存在ZCT中，如下图所示：</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/zct%E7%A4%BA%E6%84%8F%E5%9B%BE.png?x-oss-process=style/black" alt="ZCT" /></p>

<p><strong>3. 新引入的函数 scanZctToReleaseMemory</strong> 在这个函数中会遍历ZCT，释放内存。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">scanZctToReleaseMemory</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//在进行释放操作之前要对根节点引用的对象做计数器加1的动作，防止对象被误回收</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="o">((</span><span class="n">ReferenceCountObj</span><span class="o">)</span><span class="n">child</span><span class="o">).</span><span class="na">count</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Obj</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">zct</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">countObj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//对于计数器为0的对象，从ZCT中移除</span>
</span><span class='line'>        <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//并删除该对象回收内存</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">countObj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">delete</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//在进行释放操作之后要对根节点引用的对象做计数器减1的动作</span>
</span><span class='line'>    <span class="c1">//同时将计数器为0的对象也放到 ZCT中</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">zct</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">countObj</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//释放内存</span>
</span><span class='line'>    <span class="n">releaseMemory</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//减少引用对象的计数器值，如果计数器值为0，回收之</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">countObj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">childCountObj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>        <span class="n">childCountObj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">childCountObj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">delete</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以下是一个简单的对比，可以看到延迟计数法在对象计数器归零时并没有立刻回收，而原实现是立刻回收的。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/defered%E6%95%88%E6%9E%9C%E5%88%86%E6%9E%90.png?x-oss-process=style/origin" alt="效果分析" /></p>

<p>优点：延迟计数法的有点是降低了引用频繁变化带来的计数器开销。</p>

<p>缺点：延迟计数法使得垃圾不能立刻回收，同时在多线程环境中需要引入额外的同步机制保证内存清理的正确性。</p>

<h3>部分标记解决循环引用</h3>

<p><code>部分标记</code>的意思是针对部分有可能是循环引用垃圾的对象进行标记。其主要的依据是：</p>

<ul>
<li>在循环引用垃圾内部，所有对象的应用计数均由其内部对象之间的指针产生。</li>
<li>只有再删除某一对象的某个引用后该对象的引用计数仍大于零时，才有可能出现循环引用垃圾。</li>
</ul>


<p>部分标记使用四种不同的颜色来标记对象不同的状态：</p>

<ol>
<li>黑色(BLACK): 绝对不是垃圾的对象</li>
<li>白色(WHITE): 绝对是垃圾对象</li>
<li>灰色(GRAY): 搜索完毕的对象</li>
<li>阴影(HATCH): 可能是循环垃圾的对象</li>
</ol>


<p>部分标记对一个可能的循环引用垃圾进行子图追踪。对于每一个遍历到的每个引用，算法对其目标对象进行试验删除，临时性的减少目标对象的引用计数，从而移除由内部引用产生的计数。追踪完成以后，如果某个对象的计数仍然大于零，则必然是因为循环以外的其他对象引用了该对象，从而判断该对象及其循环引用都不是垃圾。</p>

<p>部分标记的逻辑比较复杂，结合图示例来讲会比较清楚一些。下图是一个引用结构的初始状态，有循环引用的对象群是<strong>ABC</strong>和<strong>DE</strong>,其中<strong>A</strong>和<strong>D</strong>由根引用。此外，<strong>C</strong>和<strong>E</strong>引用到<strong>F</strong>。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.png?x-oss-process=style/black" alt="初始状态" /></p>

<p>现在我们删除从根到A对象的引用，逻辑看代码实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">defRefCount</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//如果对象的计数变为0，则直接进行回收操作</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//循环遍历该对象引用的对象，对其进行引用减一操作</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">ReferenceCountObj</span> <span class="n">countObj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>            <span class="n">defRefCount</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">releaseMemory</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">!=</span> <span class="n">Color</span><span class="o">.</span><span class="na">HATCH</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//对象的颜色不为 HATCH的时候，将其颜色标记为 HATCH，然后加入到队列中</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">HATCH</span><span class="o">;</span>
</span><span class='line'>        <span class="n">hatchQueue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>A</strong>的引用计数减少后的状态如下图，因为<strong>A</strong>的引用计数不为零，所以是疑似的循环垃圾，被标记成了<code>HATCH</code>。
<img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E7%A7%BB%E9%99%A4%E6%A0%B9%E5%88%B0A.png?x-oss-process=style/black" alt="A" /></p>

<p>引用计数触发回收的入口都在创建对象的时候，所以创建对象的代码也需要进行修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="n">ReferenceCountObj</span> <span class="nf">newObj</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Slot</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">applySlot</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">initObj</span><span class="o">(</span><span class="n">slot</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//新对象的颜色置为黑色</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span><span class="o">;</span>
</span><span class='line'>        <span class="n">allocatedObjList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">hatchQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//如果第一次分配失败，就尝试清理疑似垃圾</span>
</span><span class='line'>        <span class="n">scanHatchQueue</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">newObj</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nf">OutOfMemoryError</span><span class="o">(</span><span class="s">&quot;------ oh, out of memory! ------&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>scanHatchQueue</code>函数会执行可以循环垃圾的子图遍历。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">scanHatchQueue</span><span class="o">(){</span>
</span><span class='line'>    <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">hatchQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">HATCH</span><span class="o">){</span>
</span><span class='line'>        <span class="c1">//通过以下三步找出循环垃圾并回收之</span>
</span><span class='line'>        <span class="n">paintGray</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="n">scanGray</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="n">collectWhite</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span><span class="k">else</span> <span class="nf">if</span><span class="o">(!</span><span class="n">hatchQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
</span><span class='line'>        <span class="n">scanHatchQueue</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>paintGray</code>函数会对目标对象进行试验删除，临时性的减少目标对象的引用计数，从而移除由内部引用产生的计数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 把对象的颜色置为 GRAY，对子对象计数器减1，递归调用 paintGray。</span>
</span><span class='line'><span class="cm"> * @param obj</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintGray</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">){</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span> <span class="o">||</span> <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">HATCH</span><span class="o">){</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">GRAY</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">ReferenceCountObj</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>            <span class="c1">// 这个地方非常重要，是子对象的计数器减1，而不是父对象。</span>
</span><span class='line'>            <span class="c1">// 否则会造成错误回收的情况。</span>
</span><span class='line'>            <span class="n">c</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>            <span class="n">paintGray</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对A及其子应用执行完<code>paintGray</code>后的状态。可以看到A,B,C,F都被标记成了灰色，A,B,C的计数为0，F的计数为1</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E6%89%AB%E6%8F%8FA.png?x-oss-process=style/black" alt="paintGray" /></p>

<p>下面详细的描述下过程:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E6%A0%87%E8%AE%B0%E5%90%8E.png?x-oss-process=style/black" alt="详细过程" /></p>

<p>首先，在(a)中A被涂成了灰色，程序对B进行了计数器减量操作。在(b)中B也被涂成了灰色，对C进行了减量操作。在&copy;中C被涂成了灰色，对A,F进行了计数器减量的操作。</p>

<p>接下来开始对灰色对象进行扫描。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">scanGray</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">GRAY</span><span class="o">){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="c1">//如果经过paintGray操作后，引用计数还是大于零，</span>
</span><span class='line'>            <span class="c1">//对象肯定有来自其他对象的引用，则将对象的颜色标记为黑色</span>
</span><span class='line'>            <span class="n">paintBlack</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//对计数为零的对象标记为白色。</span>
</span><span class='line'>            <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">WHITE</span><span class="o">;</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">ReferenceCountObj</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>                <span class="n">scanGray</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行完<code>scanGray</code>之后的状态，A,B,C都被标记成了白色，F因为有来自E的引用，所以重新被标记成了黑色。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-scanGray.png?x-oss-process=style/black" alt="scanGray" /></p>

<p>最后就是对标记为白色对象进行回收了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">collectWhite</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">){</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">WHITE</span><span class="o">){</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">ReferenceCountObj</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>            <span class="n">collectWhite</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">releaseMemory</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>回收的状态如下图，至此循环垃圾已经被回收完成了。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-collectWhite.png?x-oss-process=style/black" alt="回收完成" /></p>

<p>下图表示了在算法中四种颜色的变化示意图:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96.png?x-oss-process=style/black" alt="颜色变化" /></p>

<p><code>部分标记法</code>可以解决循环垃圾的问题，但是在效率上也存在不足。当对象很多的情况下，遍历对象的成本会变高，会增加垃圾回收的暂停时间。</p>

<h2>总结</h2>

<p>引用计数法虽然思想比较简单，但是工程实现上比较困难。在大型系统上基本上没有用武之地，但是在大多数对象的生命周期简单到直接进行管理的混合场景会比较有效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARTS First Week]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/03/21/arts-first-week/"/>
    <updated>2019-03-21T23:09:03+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/03/21/arts-first-week</id>
    <content type="html"><![CDATA[<h1>ARTS 第1周</h1>

<h2>Algorithm</h2>

<p>本周完成的算法题: <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></p>

<p>题目要求:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
</span><span class='line'>
</span><span class='line'>Your algorithm's runtime complexity must be in the order of O(log n).
</span><span class='line'>
</span><span class='line'>If the target is not found in the array, return [-1, -1].</span></code></pre></td></tr></table></div></figure>


<p><strong>分析:</strong></p>

<p>在<code>O(log n)</code> 时间复杂度的限制下，肯定是要用二分查找的。但是与普通的查找不同，这个题目实际的要求是查找目标的<code>左边界</code>和<code>右边界</code>。这样我们通过二分法查找到目标值以后，<strong>不能立刻返回</strong>，而是要继续向左或者向右查看是否有更左或者更右的目标。所以通过两次二分查找即可得到想要的结果。时间复杂度为 <code>2 * O(log n)</code></p>

<p>代码实际比较简单，就不贴代码了。</p>

<h2>Review</h2>

<p>本周Review <a href="https://medium.com/s/the-nuance/why-your-brain-needs-idle-time-e5d90b0ef1df">Why Your Brain Needs Idle Time</a></p>

<p><code>适当的休息更有助于学习和消化知识</code></p>

<p>每个人的精力是有限的，每天的工作和社交活动占用了很大的一部分，很多人只有在晚上淋浴和准备睡觉的时候才能让放松下来。</p>

<p>文中研究了<code>适当休息</code>是否会对老鼠过迷宫速度有影响。两只老鼠，一只通过迷宫后会休息下然后再重走一次迷宫，而另一只不休息直接重走。结果表明：休息过的老鼠第二次走迷宫的速度会比不休息的要<strong>快</strong>。</p>

<p>所以，不是总是让自己的大脑处于负荷运行的情况，适当的休息并不会降低效率，相反会提高效率。</p>

<h2>Tip</h2>

<p>在写代码过程中经常会碰到用一个Map来保存(K,V)结构，如果一个K有多个V的时候，我们需要指定<code>List&lt;V&gt;</code>来保存。最近我碰到了一个新的用法，使用<code>apache-commons 4</code>中的 <code>MultiValuedMap</code>可以帮助我们简化代码。</p>

<p>MultiValuedMap 的类结构如下图:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/multihashmap.jpg?x-oss-process=style/origin" alt="类结构" /></p>

<p>主要提供了两种实现：基于ArrayList的实现和基于HashSet的实现。主要区别就是在于对于<code>Key</code>是否允许重复的<code>V</code>存在。</p>

<h2>Share</h2>

<p><a href="http://linuxlsx.top/blog/2019/03/21/guan-jian-ci-pi-pei-suan-fa-diao-yan/">关键词匹配算法调研</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关键词匹配算法调研]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/03/21/guan-jian-ci-pi-pei-suan-fa-diao-yan/"/>
    <updated>2019-03-21T22:36:03+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/03/21/guan-jian-ci-pi-pei-suan-fa-diao-yan</id>
    <content type="html"><![CDATA[<p>在负责的规则系统中有很大一部分的规则是对用户输入的文本做关键词的匹配。整个关键词功能中有几个概念:</p>

<ul>
<li>匹配词：如果目标文本中存在<code>匹配词</code>，就认为规则是命中的。</li>
<li>排除词：如果目标文本中存在<code>排除词</code>，就认为规则是不命中的。</li>
</ul>


<p>其中<code>排除词</code>的优先于<code>匹配词</code>的。另外还有一个组合概念，就是只有两个或者以上的关键词命中的时候才算命中，这个在<code>排除词</code>和<code>匹配词</code>中都会有。</p>

<p>原本的实现是通过正则表达式的方式实现的。针对每个词都创建一个<code>java.regex.Pattern</code>，再对目标字符串进行匹配。</p>

<p>最新一个新业务提出了需要支持一个规则中最多包含<code>500</code>个关键词，这个长度比我们目前现有规则中最长的关键长了至少<code>10倍</code>。所以现有的实现能否满足整体的性能要求存在疑虑。</p>

<p>调研了现在常用的字符串匹配算法，发现<a href="http://cr.yp.to/bib/1975/aho.pdf">AC多模匹配算法</a>比较适合我们的场景。</p>

<h2>AC多模式匹配算法</h2>

<p>AC多模算法通过将多个关键词构造成一个有限状态机，然后再用状态机来处理输入文本。通过AC算法可以在<code>O(n)</code>时间内完成匹配，而且与关键词的长度无关。</p>

<p>AC算法的主要步骤有:</p>

<ul>
<li>为所有的关键词构造一个前缀树结构</li>
<li>针对前缀树中的每个节点计算出匹配失败后的跳转以及节点的输出</li>
<li>对目标串进行模式匹配</li>
</ul>


<p>其中在完成前两步的过程需要用到三个函数：</p>

<ul>
<li>goto  : 根据当前状态<code>s</code>以及输入字符<code>a</code> 计算出下一个状态<code>s' = goto(s, a)</code></li>
<li>fail  : 当前上一步goto函数的结果为<code>fail</code>时，需要使用该函数计算出下一个状态</li>
<li>output : 当goto函数达到某个状态时，该状态的输出内容</li>
</ul>


<h3>构造Goto Function</h3>

<p>假设现在有一组关键词{he, she, his, hers}，那么通过AC算法构造出来的步骤为:</p>

<ol>
<li><p>树的根节点为<code>0</code>。</p></li>
<li><p>输入 <code>he</code> 的到如下图。其中：<code>goto(0, h)=1 goto(1,e) = 2</code>，同时状态0到状态2得到了关键词<code>he</code>，记录<code>output(2) = [he]</code></p></li>
</ol>


<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/AC%E7%AE%97%E6%B3%95-GOTO1.png?x-oss-process=style/black" alt="AC算法-GOTO1.png" /></p>

<ol>
<li>输入 <code>she</code>。</li>
</ol>


<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/AC%E7%AE%97%E6%B3%95-GOTO2.png?x-oss-process=style/black" alt="AC算法-GOTO2.png" /></p>

<ol>
<li>输入 <code>his</code>。因为已经存在了<code>h</code>的状态转移，所以不需要从根节点开始，直接从节点1开始。</li>
</ol>


<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/AC%E7%AE%97%E6%B3%95-GOTO3.png?x-oss-process=style/black" alt="AC算法-GOTO3.png" /></p>

<ol>
<li>输入 <code>hers</code>。得到最终的树。</li>
</ol>


<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/AC%E7%AE%97%E6%B3%95-GOTO.png?x-oss-process=style/black" alt="AC算法-GOTO.png" /></p>

<h3>构造Fail Function</h3>

<p>在<code>Goto function</code>构建完成以后，就需要构建<code>Fail Function</code>。首先要引入<code>depth</code>的概念: <code>depth</code>表示在goto树中从根节点到节点<code>s</code>的最短路径。针对上述的例子来说：节点1，3的depth为1, 节点2，4，6的depth为2，节点5，7，8的depth为3，节点9的depth为4。</p>

<p>计算失效函数的思路是这样的：首先计算深度为1 的状态的失效函数值，然后是深度为2的，以此类推，直到所有状态的失效函数值都被计算出。同时，算法规定所有深度为1的状态的fail值为0，假设所有深度小于d的状态的fail值都已经计算出，考虑每个深度为d-1的状态r，基于这些已经被计算出的深度为d-1的fail值，是可以得到深度为d的fail值的。</p>

<p>假设正在计算<code>depth=d</code>的节点<code>s</code>的<code>f(s)</code>，那么需要对<code>depth=(d-1)</code>的节点<code>r</code>执行以下的流程:</p>

<ul>
<li>对于所有的字符a，如果goto(r,a) = fail，那么什么也不做</li>
<li>如果goto(r,a) == s，我们记state = <code>f(r)</code>，执行state = f(state)零次或者若干次，直到使得goto(state,a) != fail，因为goto(0,a) != fail，所以这个状态是一定存在的。</li>
<li>记fail(s) = goto(state,a)。</li>
</ul>


<p>那么针对该案例的来讲，计算过程如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. f(1),f(3)=0，因为这两个点depth=1
</span><span class='line'>2. 第二层：
</span><span class='line'>    2.1 节点2：state = f(1) = 0 =&gt; g(0, e) = 0 =&gt; f(2) = 0
</span><span class='line'>    2.2 节点6：state = f(1) = 0 =&gt; g(0, i) = 0 =&gt; f(6) = 0       
</span><span class='line'>    2.3 节点4：state = f(3) = 0 =&gt; g(0, h) = 1 =&gt; f(4) = 1
</span><span class='line'>3. 第三层：
</span><span class='line'>    3.1 节点8：state = f(2) = 0 =&gt; g(0, r) = 0 =&gt; f(8) = 0       
</span><span class='line'>    3.2 节点7：state = f(6) = 0 =&gt; g(0, s) = 3 =&gt; f(7) = 3
</span><span class='line'>    3.3 节点5：state = f(4) = 1 =&gt; g(1, e) = 2 =&gt; f(5) = 2
</span><span class='line'>4. 第四层：
</span><span class='line'>    4.1 节点9：state = f(8) = 0 =&gt; g(0, s) = 3 =&gt; f(9) = 3</span></code></pre></td></tr></table></div></figure>


<p>整体的<code>Fail Function</code>结果表为:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/tmp_table.jpg?x-oss-process=style/black" alt="结构表" /></p>

<p>增加了<code>Fail Function</code>的图为:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/AC%E7%AE%97%E6%B3%95-GOTO4.png?x-oss-process=style/black" alt="AC算法-GOTO4.png" /></p>

<h3>构造Output函数</h3>

<p><code>Output</code>函数结果的构造在以上两步中一起完成。首先在构造goto函数的时候，会把关键词增加到改关键词最后一个字符关联的节点的输出中。所以在第一步后：节点2，5，7，9的output中会有对应的关键词。</p>

<p>然后在构造<code>Fail Function</code>中，如果output(f(s)) != null，则把output(f(s))的结果添加到output(s)中。</p>

<p>以下是最终的结果表:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/tmp_table2.jpg?x-oss-process=style/black" alt="结果表" /></p>

<h3>文本匹配</h3>

<p>经过上述的步骤完成构建以后，就可以进行文本匹配了。只需要对文本从前到后进行一次遍历就可以，不需要进行回溯。</p>

<p>该过程的伪代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">begin</span>
</span><span class='line'>    <span class="n">state</span> <span class="o">&lt;-</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">until</span> <span class="n">n</span> <span class="k">do</span>
</span><span class='line'>        <span class="n">begin</span>
</span><span class='line'>            <span class="k">while</span> <span class="n">g</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span> <span class="o">==</span> <span class="n">fail</span> <span class="k">do</span> <span class="n">state</span> <span class="o">&lt;-</span> <span class="n">f</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span><span class='line'>            <span class="n">state</span> <span class="o">&lt;-</span> <span class="n">g</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">output</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">!=</span> <span class="n">empty</span> <span class="n">then</span>
</span><span class='line'>                <span class="n">begin</span>
</span><span class='line'>                    <span class="n">print</span> <span class="n">output</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span><span class='line'>                <span class="n">end</span>
</span><span class='line'>        <span class="n">end</span>
</span><span class='line'><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>性能比对</h2>

<p>待匹配文本有三种长度: 50个字符，9Kb，36Kb
关键词数量(不存在匹配词): 1个，10个，50个(存在多分组)
关键词数量(存在一个匹配词，在最前): 1个，10个，50个(存在多分组)
关键词数量(存在一个匹配词，在中间): 1个，10个，50个(存在多分组)
关键词数量(存在一个匹配词，在最后): 1个，10个，50个(存在多分组)
关键词数量500。</p>

<p>测试通过JMH框架，单线程执行，预热3次，迭代6次，取平均值，单位为opt/s。</p>

<p>如下图可以看到:</p>

<ul>
<li>1个关键词的时候，原实现性能比AC性能要好。但是AC算法和原实现也没有数量级的差异。</li>
<li>当关键词数量超过10个的时候，AC算法的性能要比原实现好。命中词在最前面算是一个特例，对于原实现来说相当于只有一个词的情况。 当然在短文本的情况下，原实现的绝对数量还是可以的，50个关键词短文本可以达到 18w次/每秒。</li>
<li>500词的情况下，AC算法有绝对的优势。</li>
</ul>


<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/AC%E7%AE%97%E6%B3%95-%E6%95%88%E6%9E%9C.png?x-oss-process=style/black" alt="AC算法-效果.png" /></p>

<p>500个关键词性能表(AC的长串性能比较高，可能是内容中的命中词比较靠前)，可以看到即使在500词的情况下，性能仍然保持在高水平。:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/tmp_table3.jpg?x-oss-process=style/black" alt="结果表" /></p>

<h2>总结</h2>

<p>AC算法在关键词比较多的情况下性能比原实现有非常明显的优势，特别是在中长文本的情况下。所以对于新需求可以通过AC算法实现，通用情况下也可以考虑使用AC算法实现替换掉。</p>

<h2>参考</h2>

<p><a href="http://cr.yp.to/bib/1975/aho.pdf">AC算法论文</a></p>

<p><a href="https://tech.meituan.com/2014/06/09/ac-algorithm-in-meituan-order-system-practice.html">AC算法在美团上单系统的应用</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[垃圾回收的算法与实现读书笔记-标记清除算法]]></title>
    <link href="http://linuxlsx.github.io/blog/2017/12/28/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-biao-ji-zheng-li-suan-fa/"/>
    <updated>2017-12-28T17:34:51+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2017/12/28/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-biao-ji-zheng-li-suan-fa</id>
    <content type="html"><![CDATA[<p>作为一个Java 程序员，得益于它的自动垃圾回收机制，极大的降低了因为编程导致的内存问题的发生几率。但是作为一个有追求的程序员，了解垃圾回收的内部实现对工作以及个人发展都是极其有帮助的。</p>

<p>在之前的工作中已经对Java 常用的GC算法有了一些浅显的理解，但是对于算法本身的实现并无深入的了解。后来在网上淘书是发现了这版本《垃圾回收的算法与实现》，试读后发现很不错。于是购买了一本打算深入的学习下。这里就是记录我学习过程中的一些记录以及根据书中伪代码实现完成简单的Java实现。</p>

<h2>GC 算法的分类</h2>

<p>GC 算法的分类主要有一下的几种：</p>

<pre><code>* 标记-清除算法  1960年 John McCarthy 发布了第一个GC算法 标记-清除算法
* 引用计数算法  1960年 George E. Collins 发布了引用计数算法。
* 复制算法  1963年 Marvin L.Minsky 发布了复制算法
* 标记-压缩算法
</code></pre>

<p>后续会按照顺序都会做一个简单的实现。</p>

<!--more-->


<h2>基本数据结构</h2>

<p>首先看下实现过程中使用的数据结构:</p>

<pre><code>* 堆。 堆是存放对象的地方。主要完成两个动作：申请指定大小的内存；释放指定大小的内存

        public class Heap {

            /**
            * 整个堆得大小
            */
            protected int size;

            /**
            * 整个堆已经分配的大小
            */
            protected int allocatedSize;

            /**
            * 堆的分配策略
            */
            protected int fitStrategy;

            public static final int FIRST_FIT_STRATEGY = 1;
            public static final int BEST_FIT_STRATEGY = 2;
            public static final int WORST_FIT_STRATEGY = 3;

            /**
            * 空闲Slot的列表
            */
            protected LinkedList&lt;Slot&gt; emptyList = new LinkedList&lt;Slot&gt;();

            /**
             * 从堆中申请一个指定大小的可用区块
            */
            public Slot applySlot(int size);

            /**
             * 释放指定大小的区块
            */
            public void release(Slot releaseSlot);
        }    

* 对象。表示一个基本的对象，可以知道该对象在内存中的起始位置、大小以及引用的对象

        public class Obj {

            /**
            * 表示对象的大小
            */
            public int size;

            /**
            * 表示对象在中的起始位置
            */
            public int start;

            /**
            * 用来表示对象之间的引用关系
            */
            public LinkedList&lt;Obj&gt; children = new LinkedList&lt;Obj&gt;();
        }

* GC 算法接口。目前只定义了一个创建对象的接口
        public interface GcAlgo {

            /**
            * 创建一个指定大小的对象
            * @param size
            * @return
            */
            Obj newObj(int size);
        }
</code></pre>

<h2>标记-清除算法</h2>

<p>标记-清除算法理解起来还是比较简单的。主要分为两个阶段：</p>

<pre><code>* 标记阶段
    * 首先标记通过根直接可以引用到的对象
    * 然后在标记所有能够访问到的对象
        * 可以通过递归做深度优先访问
        * 可以通过辅助队列做广度优先访问
* 清除阶段
    * 遍历整个堆，回收没有打上标记的对象
</code></pre>

<h3>算法实现</h3>

<p>标记-清除算法需要在对象中增加一个字段来标识对象是否已经被标记。所以我新定义了一个 <strong>MarkSweepObj</strong> 对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class MarkSweepObj extends Obj{
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * 表示对象的标记状态  true : 表示不需要清理，false : 表示需要清理
</span><span class='line'>     */
</span><span class='line'>    public boolean marked;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>基本的代码实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void markSweep() {
</span><span class='line'>    //标记阶段
</span><span class='line'>    markPhase();
</span><span class='line'>    //清除阶段
</span><span class='line'>    sweepPhase();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private void markPhase() {
</span><span class='line'>    //从根节点开始标记对象
</span><span class='line'>    for (MarkSweepObj obj : roots) {
</span><span class='line'>        mark(obj);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private void mark(MarkSweepObj obj) {
</span><span class='line'>    if (!obj.marked) {
</span><span class='line'>        obj.marked = true;
</span><span class='line'>        //如果有引用对象，则递归标记引用对象
</span><span class='line'>        if (!obj.children.isEmpty()) {
</span><span class='line'>            for (Obj child : obj.children) {
</span><span class='line'>                mark((MarkSweepObj) child);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private void sweepPhase() {
</span><span class='line'>    // allocatedObjList 记录了所有分配过的对象
</span><span class='line'>    Iterator&lt;MarkSweepObj&gt; iterator = allocatedObjList.iterator();
</span><span class='line'>    while (iterator.hasNext()) {
</span><span class='line'>        MarkSweepObj obj = iterator.next();
</span><span class='line'>        //如果对象没有标记，则说明该对象从根节点不可达，需要清理掉
</span><span class='line'>        if (!obj.marked) {
</span><span class='line'>            //release 之后会将Slot 添加到空闲列表中
</span><span class='line'>            heap.release(new Slot(obj.start, obj.size));
</span><span class='line'>            iterator.remove();
</span><span class='line'>        } else {
</span><span class='line'>            //将对象的标记归位，供下次GC使用
</span><span class='line'>            obj.marked = false;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>代码看起来可能还有些不那么直观，有图的话就会好很多了。假设下图是GC执行之前的初始状态。</p>

<p><img src="https://s1.ax1x.com/2018/01/02/ppslIe.md.png" alt="标记清除init.png" /></p>

<p>图中绿色的分块表示已经分配的对象，白色的表示空闲的内存。可以看到从根节点直接引用了两个对象，其中一个对象又引用了另外的两个对象。还有几个对象无法从根节点开始访问得到。空闲列表中包含了可用来分配的内存区块。</p>

<p>当标记阶段执行完成以后，整个堆得情况如下：</p>

<p><img src="https://s1.ax1x.com/2018/01/02/ppsuqK.md.png" alt="标记清除marked.png" /></p>

<p>可以看到从根节点开始可以访问到的对象都已经打上了对象存货的标记了。接下来就是执行清除的步骤了。</p>

<p><img src="https://s1.ax1x.com/2018/01/02/ppsMVO.md.png" alt="标记清除sweeped.png" /></p>

<p>可以看到清除之前从根节点不可达的对象都已经被清理，加入到了空闲列表中。其他存活的对象的标记也都重置了。现在空闲列表中总共有3块可供分配的内存区块，大小分别是3，2，6。</p>

<p>以上就是整个标记-清除算法的基本实现，在之前的基本结构中有个 <strong>GcAlgo</strong>，这个接口中定义的 <strong>newOb</strong> 方法又是怎么实现的呢。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * 创建一个新的对象
</span><span class='line'> *
</span><span class='line'> * @param size 对象的大小
</span><span class='line'> * @return 创建好的对象
</span><span class='line'> * @throws OutOfMemoryError 当内存无法满足分配要求时抛出
</span><span class='line'> */
</span><span class='line'>public MarkSweepObj newObj(int size) {
</span><span class='line'>
</span><span class='line'>    Slot slot = heap.applySlot(size);
</span><span class='line'>
</span><span class='line'>    //如果申请到的内存空间为null, 则执行一次GC
</span><span class='line'>    if (slot == null) {
</span><span class='line'>
</span><span class='line'>        markSweep();
</span><span class='line'>
</span><span class='line'>        slot = heap.applySlot(size);
</span><span class='line'>        //到这里还没有分配成功，说明内存已经不能满足分配的需求
</span><span class='line'>        //直接抛出 OOM 的错误
</span><span class='line'>        if (slot == null) {
</span><span class='line'>            throw new OutOfMemoryError("oh, out of memory!");
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //初始化对象
</span><span class='line'>    MarkSweepObj obj = initObj(slot);
</span><span class='line'>    //将分配好的对象添加到列表中
</span><span class='line'>    allocatedObjList.add(obj);
</span><span class='line'>
</span><span class='line'>    return obj;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//简单的对象初始化，只是记录了对象的开始位置和大小
</span><span class='line'>private MarkSweepObj initObj(Slot slot) {
</span><span class='line'>    MarkSweepObj obj = new MarkSweepObj();
</span><span class='line'>
</span><span class='line'>    obj.start = slot.start;
</span><span class='line'>    obj.size = slot.size;
</span><span class='line'>
</span><span class='line'>    return obj;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>逻辑比较简单清晰。首选就是尝试从堆中获取指定大小的内存；如果没有获取得到，就执行一次GC；完了以后再尝试一次内存分配，如果再不成功说明当前内存已经不能满足分配需求了（并不是空间就一定比需求小了），所以抛出OOM的错误。</p>

<p>以上就是这个标记-清理算法的实现逻辑了。具体的代码请查看：<a href="https://github.com/linuxlsx/Algo/tree/master/src/main/java/org/linuxlsx/gc/marksweep">标记-清理算法实现。</a></p>

<h3>执行</h3>

<p>接下来我们执行下，执行的示例代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//构建一个容量为20，采用BestFit分配策略的堆
</span><span class='line'>MarkSweepAlgo algo = new MarkSweepAlgo(20, Heap.FIRST_FIT_STRATEGY);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>try {
</span><span class='line'>    MarkSweepObj obj1 = algo.newObj(4);
</span><span class='line'>    MarkSweepObj obj2 = algo.newObj(3);
</span><span class='line'>    obj1.children.add(obj2);
</span><span class='line'>
</span><span class='line'>    MarkSweepObj obj3 = algo.newObj(3);
</span><span class='line'>    algo.makeItToRoot(obj3);
</span><span class='line'>
</span><span class='line'>    MarkSweepObj obj4 = algo.newObj(4);
</span><span class='line'>    algo.makeItToRoot(obj4);
</span><span class='line'>    MarkSweepObj obj5 = algo.newObj(2);
</span><span class='line'>    MarkSweepObj obj6 = algo.newObj(3);
</span><span class='line'>    obj4.children.add(obj5);
</span><span class='line'>    obj4.children.add(obj6);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    MarkSweepObj obj7 = algo.newObj(2);
</span><span class='line'>
</span><span class='line'>    MarkSweepObj obj8 = algo.newObj(7);
</span><span class='line'>    obj3.children.add(obj8);
</span><span class='line'>    MarkSweepObj obj9 = algo.newObj(4);
</span><span class='line'>
</span><span class='line'>    }catch (Throwable e){
</span><span class='line'>        System.out.println(e.getMessage());
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>通过以上的代码，模拟创建了如下图所示的对象结构：</p>

<p><img src="https://s1.ax1x.com/2018/01/02/ppsQaD.md.png" alt="标记清除示例初始化.png" /></p>

<p>接下来执行结果：</p>

<p><img src="https://s1.ax1x.com/2018/01/02/pps8Gd.md.jpg" alt="标记清除-算法执行结果1.png" /></p>

<p>可以看到整个过程分配了7个对象，执行了两次GC。最后一次GC执行后堆可用空间是8，这时候我们要分配的<code>obj8</code> 的大小为7，但是却抛出了oom的异常，从最后的日志可以看到，虽然可用空间有8，但是没有单个Slot 能够满足要求。</p>

<p>接下来我们对标记-清理算法做一个总结。</p>

<h3>优点</h3>

<p><code>实现简单</code>是标记-清除算法最大的优点。整个模拟的实现也就200多行代码，真正核心的更少。</p>

<h3>缺点</h3>

<p>相较于优点，标记-清除的缺点就比较多了。</p>

<pre><code>* 碎片化。这个在实际运行的时候已经看到了，在使用过程中会逐渐产生被细化的分块，尽管在总量上内存是够用的，但是实际上却因为碎片化导致对象无法分配。
* 分配速度。每次分配都需要遍历空闲列表
* 与COW(copy-on-write)技术不兼容。现代操作系统会使用COW技术来减少对象的移动，但是标记-清除算法每次都需要修改标记，就会引起不必要的对象移动。
</code></pre>

<h3>优化方案</h3>

<h4>碎片化</h4>

<p>通过适时对空闲列表进行压缩，能够比较有效的解决碎片化的问题。这个在Java 常用的 CMS GC 算法中也有体现，可以通过参数 <code>UseCMSCompactAtFullCollection</code> 和 <code>CMSFullGCsBeforeCompaction=N</code> 来设置压缩策略。</p>

<p>在我们简单的实现中，将空闲列表按照地址排序后，遍历列表将相邻的Slot 合并为一个大的Slot。以下是增加了合并功能之后的执行结果，可以看到压缩 <code>obj8</code> 分配成功了。</p>

<p><img src="https://s1.ax1x.com/2018/01/02/pps3PH.md.jpg" alt="标记清除示例压缩.png" /></p>

<h4>分配速度</h4>

<p>现在我们只使用了一个空闲列表，为了加快速度可以使用多个空闲列表。将相同大小的 Slot 放在一个列表中，这样分配的时候就直接去对应列表的第一个元素就可以了。当然空闲列表也不越多越好，对于大小超过一定限制的可以放到一个列表中。</p>

<h4>兼容COW</h4>

<p>为了能够兼容COW，所以需要将对象的标记存储其他的地方。可以使用位图标记的方式来解决。主要思路是：将堆按照指定大小划分为多个区块，然后每个区块对应到位图中的1位。这样对内存中的对象是存活的对象，就将对应的位图标记置为<code>1</code>，清理的时候就将所有标记为<code>0</code>的对象清理掉就可以了。</p>

<p>以下是简单的代码实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>public class MarkSweepWithBitMapAlgo extends MarkSweepAlgo {
</span><span class='line'>    /**
</span><span class='line'>     * 定义一个字的长度
</span><span class='line'>     */
</span><span class='line'>    public static final int WORD_LENGTH = 32;
</span><span class='line'>
</span><span class='line'>    private int[] bitmapTable;
</span><span class='line'>    private int bitmapTableSize;
</span><span class='line'>
</span><span class='line'>    public MarkSweepWithBitMapAlgo(int size, int fitStrategy) {
</span><span class='line'>        super(size, fitStrategy);
</span><span class='line'>        this.bitmapTableSize = size / WORD_LENGTH + 1;
</span><span class='line'>        //初始化位图标记
</span><span class='line'>        bitmapTable = new int[bitmapTableSize];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void markSweep() {
</span><span class='line'>        markPhase();
</span><span class='line'>        sweepPhase();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    private void markPhase() {
</span><span class='line'>        for (MarkSweepObj obj : roots) {
</span><span class='line'>            mark(obj);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    private void mark(MarkSweepObj obj) {
</span><span class='line'>
</span><span class='line'>        int index = obj.start / WORD_LENGTH;
</span><span class='line'>        int offset = obj.start % WORD_LENGTH;
</span><span class='line'>
</span><span class='line'>        if ((bitmapTable[index] & (1 &lt;&lt; offset)) == 0) {
</span><span class='line'>            //将对象对应的标志位置为 1
</span><span class='line'>            bitmapTable[index] |= (1 &lt;&lt; offset);
</span><span class='line'>            for (MarkSweepObj child : obj.children) {
</span><span class='line'>                mark(child);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    private void sweepPhase() {
</span><span class='line'>        int index, offset;
</span><span class='line'>
</span><span class='line'>        Iterator&lt;MarkSweepObj&gt; iterator = allocatedObjList.iterator();
</span><span class='line'>        while (iterator.hasNext()) {
</span><span class='line'>
</span><span class='line'>            MarkSweepObj obj = iterator.next();
</span><span class='line'>            index = obj.start / WORD_LENGTH;
</span><span class='line'>            offset = obj.start % WORD_LENGTH;
</span><span class='line'>
</span><span class='line'>            //标记完成之后标志位为0，说明该对象是需要回收的对象
</span><span class='line'>            if ((bitmapTable[index] & (1 &lt;&lt; offset)) == 0) {
</span><span class='line'>                heap.release(new Slot(obj.start, obj.size));
</span><span class='line'>                iterator.remove();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //重置标志位
</span><span class='line'>        for (int i = 0; i &lt; bitmapTableSize; i++) {
</span><span class='line'>            bitmapTable[i] = 0;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[macOS Docker 容器网络代理设置]]></title>
    <link href="http://linuxlsx.github.io/blog/2017/12/25/macos-docker-rong-qi-wang-luo-dai-li-she-zhi/"/>
    <updated>2017-12-25T10:47:46+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2017/12/25/macos-docker-rong-qi-wang-luo-dai-li-she-zhi</id>
    <content type="html"><![CDATA[<p>最近公司中绝大部分的容器都已经切换到Docker中了，所以准备深入学习下Docker 相关的内容。</p>

<p>在<a href="https://www.docker.com/community-edition">Docker官网</a>下载了最新的Mac版本，然后按照<a href="https://www.amazon.cn/dp/B015QSNIY0/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1514114219&amp;sr=1-2&amp;keywords=%E7%AC%AC%E4%B8%80%E6%9C%ACdocker%E4%B9%A6">第一本Docker书</a> 中逐步学习。不过这本书是基于Docker 1.9 版本编写，最新的Docker Mac 版本已经有了不少的变化, 不过基本的命令还是没有变化的。</p>

<!-- more -->


<p>按照书本上的例子，我下载了 ubuntu 的 docker镜像。按照 <code>docker run -i -t ubuntu /bin/bash</code> 的命令进入到容器中。按照示例接下来需要执行<code>apt-get -yqq update</code> 来更新元数据。但是在默认的配置下出现了意外的网络问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@3511c8b519ea:/# apt-get -yqq update
</span><span class='line'>W: The repository 'http://security.ubuntu.com/ubuntu xenial-security Release' does not have a Release file.
</span><span class='line'>W: The repository 'http://archive.ubuntu.com/ubuntu xenial Release' does not have a Release file.
</span><span class='line'>W: The repository 'http://archive.ubuntu.com/ubuntu xenial-updates Release' does not have a Release file.
</span><span class='line'>W: The repository 'http://archive.ubuntu.com/ubuntu xenial-backports Release' does not have a Release file.
</span><span class='line'>E: Failed to fetch http://security.ubuntu.com/ubuntu/dists/xenial-security/universe/source/Sources  Cannot initiate the connection to 6152:80 (0.0.24.8). - connect (22: Invalid argument)
</span><span class='line'>E: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/xenial/universe/source/Sources  Cannot initiate the connection to 6152:80 (0.0.24.8). - connect (22: Invalid argument)
</span><span class='line'>E: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/xenial-updates/universe/source/Sources  Cannot initiate the connection to 6152:80 (0.0.24.8). - connect (22: Invalid argument)
</span><span class='line'>E: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/xenial-backports/main/binary-amd64/Packages  Cannot initiate the connection to 6152:80 (0.0.24.8). - connect (22: Invalid argument)
</span><span class='line'>E: Some index files failed to download. They have been ignored, or old ones used instead.</span></code></pre></td></tr></table></div></figure>


<p>在网上搜索了相关资料后，发现是网络代理设置的问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@3511c8b519ea:/# set | grep proxy
</span><span class='line'>http_proxy=docker.for.mac.localhost:6152
</span><span class='line'>https_proxy=docker.for.mac.localhost:6152</span></code></pre></td></tr></table></div></figure>


<p><code>docker.for.mac.localhost</code> 是从 <strong>17.06</strong> 版本开始引入的一个Mac DNS 名称，会被解析成外部主机的IP。6152 是我设置的代理端口。</p>

<p>要想代理能够生效需要增加一个 <strong>http</strong> 的前缀：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@1e9af09f86a4:/# set | grep proxy
</span><span class='line'>http_proxy=http://docker.for.mac.localhost:6152
</span><span class='line'>https_proxy=http://docker.for.mac.localhost:6152</span></code></pre></td></tr></table></div></figure>


<p>或者直接设置不需要使用代理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@1e9af09f86a4:/# set | grep proxy
</span><span class='line'>http_proxy=no_proxy
</span><span class='line'>https_proxy=no_proxy</span></code></pre></td></tr></table></div></figure>


<p>这样设置完了以后，就可以更新 <strong>apt-get</strong> 的元数据，然后就可以安装想要的工具了。</p>

<h4>参考资料</h4>

<ol>
<li><a href="https://stackoverflow.com/questions/46632967/docker-apt-get-got-cannot-inititate-the-connection-to-800080-connect">docker apt-get got <code>Cannot inititate the connection to 8000:80 (…) - connect (22: Invalid Argument)</code></a></li>
<li><a href="https://docs.docker.com/docker-for-mac/networking/#i-cannot-ping-my-containers">Networking features in Docker for Mac</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React 实战Part 1]]></title>
    <link href="http://linuxlsx.github.io/blog/2016/08/25/react-shi-zhan-part-1/"/>
    <updated>2016-08-25T21:00:08+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2016/08/25/react-shi-zhan-part-1</id>
    <content type="html"><![CDATA[<p>React 是由FB开发的一款高性能的前端渲染框架。我们在公司的内部项目中也开始采用React 来替换原有的开发框架。由于前端资源不足，所以自告奋勇提出由自己来完成一部分的前端工作，从此开始接触到React.</p>

<!-- more -->


<p>由于我也是刚接触到React, 所以这一篇不讲(其实是讲不出来)什么原理性的东西，只是把我这几天用React 碰到的一些问题给记录下。</p>

<p>首先是推荐一款优秀的前端组件库: <code>antd</code>。是由蚂蚁金服的同学发起并维护的。<a href="http://ant.design/">官网地址</a>。整体设计非常简洁，模块化，用起来非常容易上手。</p>

<p>碰到的第一个问题其实也跟 <code>antd</code> 相关，在表单中使用了表单的 <code>getFieldProps</code> 属性。刚开始也是瞎蒙的，看着示例代码就开搞。在使用了这个属性的同时又设置了 onChange 属性。 如下:</p>

<pre><code>&lt;Select {...getFieldProps('componentId', {
    initialValue: (PageData.create &amp;&amp; PageData.create.id) ? PageData.create.componentId : '',
    rules: [
        {required: true, message: '请选择组件实例分类'},
        ],
          )} onChange={this.handleComponentChange}&gt;
            {
              this.props.componentDatas.map((o, n)=&gt;{return (
                &lt;Option value={'' + o.id} key={n}&gt;{o.name}&lt;/Option&gt;
              )})
            }
&lt;/Select&gt;
</code></pre>

<p>测试过程中碰到的问题就是死活无法选中下拉框中的选项，但是事件又触发了。去掉<code>onChange</code> 属性能够选中选项，但没法处理事件。检查文档发现 <code>getFieldProps</code> 已经包含了<code>id</code> <code>value</code> <code>ref</code> <code>onChange</code> 属性，不能重复设置属性。 所以正确的做法是在 <code>getFieldProps</code> 中指定时间处理函数。</p>

<p>第二个问题跟CodeMirror相关。项目中需要编辑代码，自然想到就是将CodeMirror引入到项目中来。搜索后发现<a href="https://github.com/JedWatson/react-codemirror">react-codemirror</a> 还不错，就引入到项目中。第一次尝试很成功一次就过，但是当同一个页面中出现多个CodeMirror 的实例时会出现 <strong>状态变化后, 只有最底下的一个实例能够响应状态的变更</strong>。这个显然不是我想要的结果。GitHub 项目中的 issue 是个好东西，你碰到过的问题肯定有其他人也碰到过。该项目的
 <a href="https://github.com/JedWatson/react-codemirror/issues/46">issue #46</a> <a href="https://github.com/JedWatson/react-codemirror/issues/47">issue #47</a> <a href="https://github.com/JedWatson/react-codemirror/issues/49">issue #49</a>都提到了这个问题。 这个问题的原因就是 <code>componentWillReceiveProps</code> 这个方法被 <code>debounce</code> 后变成异步执行的了，所有只会有最后一个实例才会收到状态变更的消息。</p>

<p> 解决办法就是将 <code>componentWillReceiveProps</code> 改为同步执行的。目前作者还没有修复这个问题，只能在代码中通过重写这个方法来完成。具体的实现参见 <a href="https://github.com/mozilla-services/react-jsonschema-form/pull/175">解决方案</a></p>

<p>两个问题都不是什么大问题，但是从发现问题到解决问题还是花费了我不少的时间。三个解决问题的经验:</p>

<ul>
<li>查看文档。文档中通常都会详细的说明一些需要特殊注意的场景，而这些场景往往就是出问题的地方。</li>
<li>如果是开源项目，那就先检查 issues 中是否已经有过类似的问题了。看是不是可以通过升级版本解决问题。</li>
<li>再不行的话只能通过万能的 Google 了，前提是要能科学上网。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[缓存设计思路]]></title>
    <link href="http://linuxlsx.github.io/blog/2016/03/02/huan-cun-she-ji-si-lu/"/>
    <updated>2016-03-02T22:04:57+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2016/03/02/huan-cun-she-ji-si-lu</id>
    <content type="html"><![CDATA[<p>无意中读到陈天的<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=401641618&amp;idx=1&amp;sn=3a6dbb475ceb85a4610e49910443a098&amp;scene=4#wechat_redirect">谈谈系统设计面试</a> 对于其中的一些思想深以为然。看待问题不能只看表象，需要深入的了解问题的背景、原因以及解决问题的预期目标，只有了解了这些以后才能给出一个完整、有效的解决方案。</p>

<!-- more -->


<p>以下是我读完后结合自己的实践写一个总结。
问题: 某个系统出现性能瓶颈, 现在需要你给出一套缓存方案来解决性能问题。</p>

<p>步骤1: 了解问题的背景</p>

<pre><code>1. 当前性能情况怎么样。QPS,TPS,RT多少, 数据量有多少.
2. 当前系统架构如何。是否已经使用缓存
3. 系能的瓶颈在哪里。是数据库压力大,还是应用服务器压力大
</code></pre>

<p>步骤2: 了解缓存的对象</p>

<pre><code>1. 数据是什么类型, 占用多少空间(最小/平均/最大)。不同的空间占用有不同的缓存方案。
2. 数据的读写比怎样。
</code></pre>

<p>步骤3: 了解目标</p>

<pre><code>1. 预期的性能是多少。QPS,TPS,RT等   
2. 能够使用的资源有多少。
</code></pre>

<p>步骤4: 了解工具</p>

<pre><code>1. 有哪些工具可用。
2. 这些工具能达到的性能以及适合使用场景
3. 公司内部是否对这些工具有成熟的运维工具, 否则需要在设计缓存管理的工具
</code></pre>

<p>步骤5: 提出方案</p>

<pre><code>1. 方案review及修改
2. 根据方案开始实施
</code></pre>

<p>步骤6: 方案成果分析</p>

<pre><code>1. 收集方案实施前后的性能数据
2. 对比性能数据判断方案是否达到预期目标
</code></pre>

<p>按照这6个步骤执行,一般来说会得到一个理想的结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[requireJs 配置可重用]]></title>
    <link href="http://linuxlsx.github.io/blog/2016/01/15/requirejs-pei-zhi-ke-zhong-yong/"/>
    <updated>2016-01-15T13:53:16+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2016/01/15/requirejs-pei-zhi-ke-zhong-yong</id>
    <content type="html"><![CDATA[<p>最近做项目的时候需要配套一个后台界面供运营人员查看相关数据。因为后台应用没有专职的前端, 所以一般的做法是找一套 bootstrap 的模板, 然后再实现具体的逻辑。一般的 javascript 逻辑都是写个每个页面里面的，没什么重用性。想通过模块的方式来实现重用, 需要有个东西来管理模块之间的依赖, 正好有其他的后台应用使用了require.js, 就照样使用了起来。</p>

<!-- more -->


<p>具体关于 require.js 的使用介绍网上有很多, 我也看了好几篇, 推荐几篇比较靠谱的:</p>

<ol>
<li>JavaScript模块化开发系列. <a href="http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-basics/">第一篇</a> <a href="http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-commonjs/">第二篇</a> <a href="http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-amd/">第三篇</a> <a href="http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-requirejs/">第4篇</a></li>
<li>阮一峰的<code>Javascript模块化编程</code>系列. <a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">第一篇</a> <a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html">第二篇</a> <a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html">第三篇</a></li>
</ol>


<p>学习完了以后对 require.js 以及 AMD 相关的概念有了一定的了解。也达到了模块化开发的目标。这里主要想说明的一个问题是如何使 require.js 的全局配置能达到重用的效果。</p>

<p>这个是我一个页面的JS模块:</p>

<pre><code>requirejs.config({
    baseUrl : "/assets",

    shim : {
        "bootstrap" : { "deps" :['jquery'] },
        "dist" :{"deps" :['bootstrap']},
        "paginator" : {"deps" : ['jquery']},
        "menu" :{"deps": ['jquery']}
    },

    paths: {
        jquery: 'plugins/jQuery/jQuery-2.1.4.min',
        bootstrap : 'bootstrap/js/bootstrap.min',
        dist: 'dist/js/app',
        paginator : 'plugins/bootstrap-paginator/bootstrap-paginator',
        menu : 'page/module/menu',
        pager : 'page/module/simplepager',
    }
});
require(['jquery', 'bootstrap', 'dist', 'paginator' , 'menu', 'pager'],function($, bootstrap, dist, paginator ,menu, pager){

    $(document).ready(function(){

        var init = function(){
            menu.initMenu();
            pager.initPager();
        }

        init();
    });
  });
</code></pre>

<p><code>requirejs.config()</code> 其实是一个全局的配置, 但是按照标准的 requireJs 的引入方法是无法重用这个配置的。 在开始阶段我不得不在每个页面中重复的拷贝这个配置。对于有节操的码农来说这是不可接受的。所以我开始寻找解决重复配置的方法, 终于在<code>stackoverflow</code>上找到了答案。<a href="http://stackoverflow.com/questions/16067042/requirejs-and-common-config">原始的问题链接</a></p>

<p>解决的主要方法就是分开引入。先引入 require.js, 再引入你的全部配置 config.js, 然后在引入你要执行的模块。</p>

<pre><code>//1. 首先引入 require.js
&lt;script src="http://linuxlsx.github.io/assets/require.js"  type="text/javascript" &gt;&lt;/script&gt;
//2. 引入全部的配置文件
&lt;script src="http://linuxlsx.github.io/assets/config.js" type="text/javascript" &gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
    //3. 引入你要执行的模块
    require(['/assets/page/feedback.js'])
&lt;/script&gt;
</code></pre>

<p>通过以上的配置就能减少代码重复了。另外有文章提到可以通过 require.js 的插件机制来达到效果，但是没有找到可行的解决方案。</p>

<h5>参考资料</h5>

<ol>
<li><a href="http://requirejs.org/">require.js官网</a></li>
<li><a href="https://github.com/togakangaroo/Blog/blob/master/setting-up-requirejs.md">setting-up-requirejs</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringMVC 使用AOP拦截Controller]]></title>
    <link href="http://linuxlsx.github.io/blog/2016/01/14/springmvc-shi-yong-aoplan-jie-controller/"/>
    <updated>2016-01-14T19:44:22+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2016/01/14/springmvc-shi-yong-aoplan-jie-controller</id>
    <content type="html"><![CDATA[<p>最近使用SpringMVC开发一个后台应用, 要求对操作进行权限控制并记录操作日志。这是典型的AOP应用场景, 所以自然而然的想通过 AOP 拦截 SpringMVC 的 Controller 执行来达到想要的效果. 但是在按照之前的配置调试的时候, AOP的拦截代码并没有得到执行。经过几番研究后找到了答案。</p>

<!-- more -->


<p>首先因为 SpringMVC 的 Controller 是没有接口的, 但是Spring 默认使用的JDK的动态代理。动态代理会限制必须有接口才行，所以在配置上要指定使用cglib代理。通过以下的配置可以指定 Spring 使用 cglib:</p>

<pre><code>&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;
</code></pre>

<p>但是要想达到想要的效果, 这个配置的声明位置还有讲究。这个主要是 Spring 的父子容器访问规则导致的。子容器可以访问父容器中配置的bean, 但是父容器不能访问子容器中的bean .</p>

<p>SpringMVC 实现的时候就是这样一个父子结构。通过 <code>ContextLoaderListener</code> 创建的容器作为父容器。 每个 <code>DispatcherServlet</code> 创建的容器作为子容器。</p>

<p>所以当把上面的申明放到父容器相关的配置文件中的时候, 父容器会尝试寻找切入点, 但是这个时候切入点其实在子容器, 父容器访问不到子容器中的bean, 达不到拦截的效果。</p>

<p>将配置迁移到 子容器相关的配置文件中就能达到拦截的效果。至于 Aspect 的bean 可以配置在父容器中 也可以配置在子容器中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Synchronized 作用于局部变量]]></title>
    <link href="http://linuxlsx.github.io/blog/2015/12/10/synchronized-local-variable-string/"/>
    <updated>2015-12-10T20:36:22+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2015/12/10/synchronized-local-variable-string</id>
    <content type="html"><![CDATA[<p><code>synchronized</code> 是java 中元老级的锁。他的使用非常的简单, 可以作用在普通方法，静态方法以及方法块上。对象是 <code>synchronized</code> 实现同步的基础，java 中每个对象都可以作为锁。具体表现为以下三种方式:</p>

<pre><code>1. 对于普通方法, 锁是当前对象的实例
2. 对于静态同步方法, 锁是当前类的 Class 对象
3. 对于同步方法块, 锁是 synchronized 括号里面配置的对象
</code></pre>

<!-- more -->


<p>今天代码review 的时候, 发现一个新奇的写法，简化后的代码如下:</p>

<pre><code>public static Object get(String key){

  String syncKey = key + "something else";

  synchronized (syncKey){
      // 简化的逻辑
      // obj = map.get(syncKey)
      // if obj == null
      //      obj = Provider.get()
      //      map.put(obj)
      // return obj
  }
}
</code></pre>

<p>咋一看这跟我们常规的写法不一样，常规的写法 一般是将 <code>syncKey</code> 定义为类的一个属性, 这样能够保证多线程确实是基于同一个对象实例来做同步的。对于这个写法作者的解释是 java 对于String 是做过特殊处理的，值一样的String 是会做缓存的。所以多线程访问的情况下仍然是作用在同一个对象上, 可以达到同步的效果。</p>

<p>对于这个结论是一半对一半不对, 具体能不能达到想要的同步效果，就要看是不是作用在同一个对象实例上。那String 到底是不是同一个对象实例呢？ 那就要从 String 的内存模型说起了。具体详解可以参考<a href="http://www.cnblogs.com/ITtangtang/p/3976820.html">深入理解Java：String</a></p>

<p>所以针对这个示例，其实是不对的。 <code>String syncKey = key + "something else"</code> 每次都返回一个 <code>new String()</code> 对于 <code>synchronized</code> 来说肯定不是同一个对象实例, 所以就达不到同步的效果。但是如果修改成如下的就是可以的:</p>

<pre><code>public static Object get(String key){

  String syncKey = "something else";

  synchronized (syncKey){
      // 简化的逻辑
      // obj = map.get(syncKey)
      // if obj == null
      //      obj = Provider.get()
      //      map.put(obj)
      // return obj
  }
}
</code></pre>

<p><code>String syncKey = "something else";</code> 这样的方式是将 <code>something else</code> 这个字符串保存到了JVM 的字符串常量池中, 并且可以共享。所以多线程访问的时候拿到的都是同一个对象, 就能达到同步的效果。</p>

<p>Java 还有没有能够达到这种效果的对象吗？答案是肯定的, 以下的几种情况得到的都是同一个对象实例:</p>

<pre><code>1. byte(Byte), short(Short), int(Integer), long(Long) 值在[-128,127] 之间
2. boolean (true or false)
3. char 值在 ['\u0000' - '\u007f']
</code></pre>

<p>这个是Java 语言规范中定义的。这些值会在JVM中缓存下来, 每次使用都会返回同一个实例。但是仅限<code>Integer i = 1</code> 这样的方式. 如果是 <code>Integer i = new Integer(1)</code> 的话， 那就是不同的对象了。</p>

<h4>结论</h4>

<p><code>synchronized</code> 将锁标记保存在对象头中, 所以只要对象是同一个就能够达到同步的效果，也不一定要是实例变量。而Java 语言中某些对象实例虽然是局部变量, 但是由于一些性能优化上的考虑, 会对String, Byte,Short,Boolean,Integer,Long 类型的数据做一些优化。</p>

<h4>参考资料</h4>

<ol>
<li><a href="http://www.cnblogs.com/ITtangtang/p/3976820.html">深入理解Java: String</a></li>
<li><a href="http://java-performance.info/string-intern-in-java-6-7-8/">String.intern in Java 6, 7 and 8 – string pooling</a></li>
<li><a href="http://codelog.me/2015/01/20/2015-01-20-string-intern/">深入理解Java String#intern() 内存模型</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jrebel VerifyError]]></title>
    <link href="http://linuxlsx.github.io/blog/2015/12/04/jrebel-verifyerror/"/>
    <updated>2015-12-04T15:40:14+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2015/12/04/jrebel-verifyerror</id>
    <content type="html"><![CDATA[<p>Jrebel 动态部署极大提高了开发效率，是开发必备神器之一. 个人也使用了2年多了，一直都非常顺手.  但是今天启动应用的时候，报了如下的错误:</p>

<pre><code>Caused by: java.lang.VerifyError: Bad &lt;init&gt; method call from inside of a branch
Exception Details:
Location:
  com/taobao/healthcenter/web/servlet/StatusServlet.&lt;init&gt;(Lcom/zeroturnaround/javarebel/Ge;I[Ljava/lang/Object;)V @11: invokespecial
Reason:
  Error exists in the bytecode
Bytecode:
  0000000: 04b8 008e c600 0b2a 2b1c 2db7 0113 b112
  0000010: 771c b800 7dbf                         
Stackmap Table:
  same_frame(@15)

  java version : 1.7.0_67
  jrebel version : 6.0.0
</code></pre>

<p>Google 发现Jrebel官网已经有人提出了这个问题: <a href="http://zeroturnaround.com/forums/topic/verifyerror-bad-method-call-from-inside-of-a-branch/">VerifyError</a></p>

<!-- more -->


<p>根据帖子中提到的<a href="https://bugs.openjdk.java.net/browse/JDK-8051012">JDK Bug</a> 1.7版本最早修复该bug 的版本是 7u72.</p>

<p>根据帖子中提供的方案在JVM参数中添加 <code>-noverify</code> 解决问题。</p>

<h5>Tip</h5>

<p>我其实用 jdk7 和 jrebel 6 已经好久了，为什么今天就碰到这个问题了呢。 通过对比发现是: 之前我都是将 Java 的编译版本设置为了 1.6, 而今天出问题的时候我将编译版本设置成了 1.7, 而jdk7 相比 jdk6 生成的字节码引入了一些功能, 导致 jrebel 修改字节码后会出现一些验证的问题。</p>

<p>原本打算直接升级到 jdk8 的， 但是受限于公司规定的框架只能先升级到 jdk7. 看来还要等会才能在线上使用 lambda 了</p>

<h4>参考资料</h4>

<ol>
<li><a href="http://chrononsystems.com/blog/java-7-design-flaw-leads-to-huge-backward-step-for-the-jvm">Java 7 Bytecode Verifier: Huge backward step for the JVM</a></li>
<li><a href="http://stackoverflow.com/questions/300639/use-of-noverify-when-launching-java-apps">Use of -noverify when launching java apps</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
