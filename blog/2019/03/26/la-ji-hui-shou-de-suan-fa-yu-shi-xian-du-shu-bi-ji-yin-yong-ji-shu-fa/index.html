
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>垃圾回收的算法与实现读书笔记-引用计数法 - 平凡的世界</title>
  <meta name="author" content="linuxlsx">

  
  <meta name="description" content="在上一篇文章中介绍了标记-清除法的实现，这边接着来讲引用计数法的实现 文中部分图片引用自《垃圾回收的算法与实现》一书，如有版权问题，请联系删除。 引用计数法 引用计数法是George E.Colins 在1960年提出来的。主要思想是: 1
让每个对象都记录下被多个其他对象引用的数量， &hellip;">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  
  <link rel="canonical" href="http://linuxlsx.github.io/blog/2019/03/26/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-yin-yong-ji-shu-fa">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="平凡的世界" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="https://fonts.proxy.ustclug.org/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.proxy.ustclug.org/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-111612120-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <div id="sidebar_control"></div>
  <div id="sidebar">
    <div class="logo">
      .lsx
    </div>
    <div class="content hide">
      <section role="navigation">
        <header role="banner"><hgroup>
  <h1><a href="/">平凡的世界</a></h1>
  
    <h2>Hello Little Cat</h2>
  
</hgroup>

</header>
        
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:linuxlsx.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>

<ul class="main-navigation">
  <li><a href="/">home</a></li>
</ul>


      </section>
      
        <section>
  <h2>recent</h2>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2019/09/01/arts-week-11/">ARTS 第11周 零拷贝</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/07/02/arts-week-10/">ARTS 第10周 流控算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/06/13/arts-week-9/">ARTS 第9周 晋升述职</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/05/24/arts-week-8/">ARTS 第8周 学习的10个步骤</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/05/05/arts-week-7/">ARTS 第7周 动态规划</a>
      </li>
    
  </ul>
</section>

<section>
  <h2>github</h2>
  
  <a href="https://github.com/linuxlsx">@linuxlsx</a>
  
  <ul id="gh_repos">
  </ul>
</section>





      
    </div>
  </div>
  <div id="main">
    <div class="content">
      <article class="hentry" role="article">
  
  
    <header>
      <div class="back"><a href="/" onclick="history.go(-1);return false;">← Back</a></div>
      <h1 class="entry-title">垃圾回收的算法与实现读书笔记-引用计数法</h1>
    </header>
  
  <div class="entry-content"><p>在<a href="http://linuxlsx.top/blog/2017/12/28/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-biao-ji-zheng-li-suan-fa/">上一篇文章</a>中介绍了<code>标记-清除法</code>的实现，这边接着来讲<code>引用计数法</code>的实现</p>

<p>文中部分图片引用自《垃圾回收的算法与实现》一书，如有版权问题，请联系删除。</p>

<h1>引用计数法</h1>

<p><code>引用计数法</code>是George E.Colins 在1960年提出来的。主要思想是:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="err">让每个对象都记录下被多个其他对象引用的数量，当没有其他对象引用时，就可以让该对象被回收。</span>
</span></code></pre></td></tr></table></div></figure>


<p>引用计数算法理解起来比较简单。首先来看下伪代码</p>

<!-- more -->


<h2>伪代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="c1">//分配对象</span>
</span><span class='line'><span class="n">new_obj</span><span class="p">(</span><span class="n">size</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//向堆请求内存分配</span>
</span><span class='line'>    <span class="n">obj</span> <span class="o">=</span> <span class="n">pickup_chunk</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="err">$</span><span class="n">free_list</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>        <span class="c1">//如果请求失败的话，直接失败</span>
</span><span class='line'>        <span class="n">allocation_fail</span><span class="p">()</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="c1">//设置初始的引用计数为 1</span>
</span><span class='line'>        <span class="n">obj</span><span class="p">.</span><span class="n">ref_cnt</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">//引用变化时更新引用计数 ptr-&gt;obj</span>
</span><span class='line'><span class="n">update_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">obj</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">//增加obj的计数</span>
</span><span class='line'>    <span class="n">inc_ref_cnt</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span><span class='line'>    <span class="c1">//减少原对象的计数</span>
</span><span class='line'>    <span class="n">dec_ref_cnt</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
</span><span class='line'>    <span class="c1">//更新引用</span>
</span><span class='line'>    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">obj</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//增加对象的引用计数</span>
</span><span class='line'><span class="n">inc_ref_cnt</span><span class="p">(</span><span class="n">obj</span><span class="p">){</span>
</span><span class='line'>    <span class="n">obj</span><span class="p">.</span><span class="n">ref_cnt</span><span class="o">++</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//减少对象的引用计数，在这里进行回收</span>
</span><span class='line'><span class="n">def_ref_cnt</span><span class="p">(</span><span class="n">obj</span><span class="p">){</span>
</span><span class='line'>    <span class="n">obj</span><span class="p">.</span><span class="n">ref_cnt</span><span class="o">--</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">ref_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="c1">//当对象的引用计数为0时，遍历所有引用的对象，并将它们的计数减 1</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="nl">child</span> <span class="p">:</span> <span class="n">children</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</span><span class='line'>            <span class="n">def_ref_cnt</span><span class="p">(</span><span class="o">*</span><span class="n">child</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//释放对象，回收内存</span>
</span><span class='line'>        <span class="n">reclaim</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>更新对象计数时需要先增加目标对象的计数，然后再减少源对象的计数器。这样是为了防止目标对象和源对象是同一个对象时，先减少源对象计数器可能会导致对象计数器归零，被当成垃圾回收掉。</p>

<h2>数据结构</h2>

<p>为了实现引用计数法，需要在对象头中增加一个<code>引用计数器</code>。新的数据结构为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReferenceCountObj</span> <span class="kd">extends</span> <span class="n">Obj</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 表示该对象的引用计数</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Obj</code>对象的定义见<a href="http://linuxlsx.top/blog/2017/12/28/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-biao-ji-zheng-li-suan-fa/">标记-清除法</a></p>

<h2>算法实现</h2>

<p>引用计数算法中主要的处理在<code>update_ptr</code>函数。请看下图，初始状态从根引用<strong>A</strong>和<strong>C</strong>，从<strong>A</strong>引用<strong>B</strong>。<strong>A</strong>持有指向<strong>B</strong>的唯一指针，假设现在将该指针更新到<strong>C</strong>。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/update_ptr%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0.png?x-oss-process=style/black" alt="update_ptr" /></p>

<p>通过以上的更新，<strong>B</strong>的计数器值变成了<strong>0</strong>，因此<strong>B</strong>被回收了，且<strong>B</strong>连上了空闲列表，可以被重新利用。又因为新形成了由<strong>A</strong>指向<strong>C</strong>的指针，所以<strong>C</strong>的计数器的值增为<strong>2</strong>。</p>

<p>以下是具体的一个实现代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReferenceCountAlgo</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">Heap</span> <span class="n">heap</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ReferenceCountAlgo</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fitStrategy</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Heap</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">fitStrategy</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 表示GC 的根</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">ReferenceCountObj</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReferenceCountObj</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 表示已经分配过的对象列表</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">ReferenceCountObj</span><span class="o">&gt;</span> <span class="n">allocatedObjList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 创建一个新的对象</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @param size 对象的大小</span>
</span><span class='line'><span class="cm">     * @return 创建好的对象</span>
</span><span class='line'><span class="cm">     * @throws OutOfMemoryError 当内存无法满足分配要求时抛出</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">ReferenceCountObj</span> <span class="nf">newObj</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Slot</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">applySlot</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//对于引用计数法来说，如果slot 为空，说明内存已经耗尽了</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">slot</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">OutOfMemoryError</span><span class="o">(</span><span class="s">&quot;------ oh, out of memory! ------&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">initObj</span><span class="o">(</span><span class="n">slot</span><span class="o">);</span>
</span><span class='line'>        <span class="n">allocatedObjList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 建立对象之间的引用关系。 相当于 from = to</span>
</span><span class='line'><span class="cm">     * @param from      引用的起始对象。</span>
</span><span class='line'><span class="cm">     * @param to        应用的目标对象。该对象的引用计数需要加一</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reference</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">from</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">incrRefCount</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 删除对象之间的引用关系。相当于 from = null</span>
</span><span class='line'><span class="cm">     * @param from    引用 &#39;需要解除引用对象&#39; 的对象。 如果 from == null, 说明是要解除和根的引用</span>
</span><span class='line'><span class="cm">     * @param to      需要解除引用的对象。该对象的引用计数会减一</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deReference</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">from</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">to</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">from</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
</span><span class='line'>            <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">defRefCount</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 修改对象的引用关系。相当于从 from = oldTo 变化为 from = newTo</span>
</span><span class='line'><span class="cm">     * @param from</span>
</span><span class='line'><span class="cm">     * @param oldTo</span>
</span><span class='line'><span class="cm">     * @param newTo</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeReference</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">from</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">oldTo</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">newTo</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">oldTo</span><span class="o">);</span>
</span><span class='line'>        <span class="n">defRefCount</span><span class="o">(</span><span class="n">oldTo</span><span class="o">);</span>
</span><span class='line'>        <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newTo</span><span class="o">);</span>
</span><span class='line'>        <span class="n">incrRefCount</span><span class="o">(</span><span class="n">newTo</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">incrRefCount</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">defRefCount</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//如果对象的计数变为0，则直接进行回收操作</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">//循环遍历该对象引用的对象，对其进行引用减一操作</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">ReferenceCountObj</span> <span class="n">countObj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>                <span class="n">defRefCount</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">//释放掉内存</span>
</span><span class='line'>            <span class="n">heap</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="k">new</span> <span class="nf">Slot</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">start</span><span class="o">,</span> <span class="n">obj</span><span class="o">.</span><span class="na">size</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">ReferenceCountObj</span> <span class="nf">initObj</span><span class="o">(</span><span class="n">Slot</span> <span class="n">slot</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReferenceCountObj</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">slot</span><span class="o">.</span><span class="na">start</span><span class="o">;</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">slot</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
</span><span class='line'>        <span class="c1">//对象的初始化引用计数为 0</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 把对象置为根节点</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     * @param obj 根对象</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeItToRoot</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>引用计数法的优点</h3>

<pre><code>* 当对象的计数器归零后可立刻回收
* 最大暂停时间短。在操作对象的时候同时进行垃圾回收，不需要专门的阶段来进行回收
* 回收只需要考虑当前对象及其所以引用的对象，不需要从根对象开始
</code></pre>

<h3>引用计数法的缺点</h3>

<pre><code>* 循环引用无法回收。
* 计数器会带来额外的读/写开销，频繁的写操作可能会导致高速缓存失效。所以引用计数法不适合通用的大容量、高性能的内存管理场景。
* 用于计数的计数器必须能够满足一个对象引用堆中所有其他对象的极端情况。所有计数器大小必须和引用类型一样大，会造成内存浪费。
* 在多线程环境中需要保证引用计数的增减以及加载和存储指针的操作都必须原子化。
</code></pre>

<h2>算法优化</h2>

<pre><code>1. 降低计数器带来的开销
   1.1 延迟计数法。将应用计数延迟某个阶段统一的执行
   1.2 合并计数法。不在每次变更都更新计数器，而是关注开始和结束状态，对中间的变更进行合并。
2. 解决循环引用无法回收的问题
   2.1 通过部分标记的方法解决循环引用的问题。
</code></pre>

<h3>延迟计数法</h3>

<p>在<code>延迟计数法</code>中，引入了一个新的结构ZCT(Zero Count Table)，来保存计数器归零的对象。相比原来的实现，有以下几个步骤需要进行调整。</p>

<p><strong>1. 创建对象</strong> 当对象内存分配失败时，要先遍历下ZCT释放内存，然后再次尝试申请内存，如果还是失败的话，就真的是内存不足了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="n">ReferenceCountObj</span> <span class="nf">newObj</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Slot</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">applySlot</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">//对于引用计数法来说，如果slot 为空</span>
</span><span class='line'>    <span class="c1">//不直接抛出OOM，而是释放掉ZCT中可以释放的对象</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">slot</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">scanZctToReleaseMemory</span><span class="o">();</span>
</span><span class='line'>        <span class="n">slot</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">applySlot</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">slot</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">OutOfMemoryError</span><span class="o">(</span><span class="s">&quot;------ oh, out of memory! ------&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">initObj</span><span class="o">(</span><span class="n">slot</span><span class="o">);</span>
</span><span class='line'>    <span class="n">allocatedObjList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>2. 计数器操作</strong> 当对象计数器的值降到<code>0</code>时，不要直接将对象回收，而是将对象添加到ZCT中。另外为了减少从根节点应用的对象的计数器频繁变更，规定当应用是来自根节点的时候，计数器不加<code>1</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'>   <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 模拟和根节点建立引用关系</span>
</span><span class='line'><span class="cm">     * @param obj 根对象</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeItToRoot</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//如果对象的应用是来自根节点，那么就不要修改对象的计数器</span>
</span><span class='line'>        <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//因为对象的计数器为0，所以将其放到ZCT中</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">isFull</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">scanZctToReleaseMemory</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">zct</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deReference</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">from</span><span class="o">,</span> <span class="n">ReferenceCountObj</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//因为根节点引用的对象初始计数器为0，所以释放的时候不需要操作计数器</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">from</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
</span><span class='line'>            <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">from</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>            <span class="n">defRefCount</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 与原始实现不同，当计数器变成0时，将对象放到ZCT中而不是直接释放</span>
</span><span class='line'><span class="cm">     * @param obj</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">defRefCount</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//如果对象的计数变为0，则优先把对象放到zct中</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//如果队列满了，则释放掉队列中的对象</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">isFull</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">scanZctToReleaseMemory</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">zct</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>引入ZCT后，根节点引用的对象和计数器为0的对象同时存在ZCT中，如下图所示：</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/zct%E7%A4%BA%E6%84%8F%E5%9B%BE.png?x-oss-process=style/black" alt="ZCT" /></p>

<p><strong>3. 新引入的函数 scanZctToReleaseMemory</strong> 在这个函数中会遍历ZCT，释放内存。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">scanZctToReleaseMemory</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//在进行释放操作之前要对根节点引用的对象做计数器加1的动作，防止对象被误回收</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="o">((</span><span class="n">ReferenceCountObj</span><span class="o">)</span><span class="n">child</span><span class="o">).</span><span class="na">count</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Obj</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">zct</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">countObj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//对于计数器为0的对象，从ZCT中移除</span>
</span><span class='line'>        <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//并删除该对象回收内存</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">countObj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">delete</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//在进行释放操作之后要对根节点引用的对象做计数器减1的动作</span>
</span><span class='line'>    <span class="c1">//同时将计数器为0的对象也放到 ZCT中</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">zct</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">countObj</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//释放内存</span>
</span><span class='line'>    <span class="n">releaseMemory</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//减少引用对象的计数器值，如果计数器值为0，回收之</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">countObj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">childCountObj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>        <span class="n">childCountObj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">childCountObj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="n">delete</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以下是一个简单的对比，可以看到延迟计数法在对象计数器归零时并没有立刻回收，而原实现是立刻回收的。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/defered%E6%95%88%E6%9E%9C%E5%88%86%E6%9E%90.png?x-oss-process=style/origin" alt="效果分析" /></p>

<p>优点：延迟计数法的有点是降低了引用频繁变化带来的计数器开销。</p>

<p>缺点：延迟计数法使得垃圾不能立刻回收，同时在多线程环境中需要引入额外的同步机制保证内存清理的正确性。</p>

<h3>部分标记解决循环引用</h3>

<p><code>部分标记</code>的意思是针对部分有可能是循环引用垃圾的对象进行标记。其主要的依据是：</p>

<ul>
<li>在循环引用垃圾内部，所有对象的应用计数均由其内部对象之间的指针产生。</li>
<li>只有再删除某一对象的某个引用后该对象的引用计数仍大于零时，才有可能出现循环引用垃圾。</li>
</ul>


<p>部分标记使用四种不同的颜色来标记对象不同的状态：</p>

<ol>
<li>黑色(BLACK): 绝对不是垃圾的对象</li>
<li>白色(WHITE): 绝对是垃圾对象</li>
<li>灰色(GRAY): 搜索完毕的对象</li>
<li>阴影(HATCH): 可能是循环垃圾的对象</li>
</ol>


<p>部分标记对一个可能的循环引用垃圾进行子图追踪。对于每一个遍历到的每个引用，算法对其目标对象进行试验删除，临时性的减少目标对象的引用计数，从而移除由内部引用产生的计数。追踪完成以后，如果某个对象的计数仍然大于零，则必然是因为循环以外的其他对象引用了该对象，从而判断该对象及其循环引用都不是垃圾。</p>

<p>部分标记的逻辑比较复杂，结合图示例来讲会比较清楚一些。下图是一个引用结构的初始状态，有循环引用的对象群是<strong>ABC</strong>和<strong>DE</strong>,其中<strong>A</strong>和<strong>D</strong>由根引用。此外，<strong>C</strong>和<strong>E</strong>引用到<strong>F</strong>。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.png?x-oss-process=style/black" alt="初始状态" /></p>

<p>现在我们删除从根到A对象的引用，逻辑看代码实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">defRefCount</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//如果对象的计数变为0，则直接进行回收操作</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//循环遍历该对象引用的对象，对其进行引用减一操作</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">ReferenceCountObj</span> <span class="n">countObj</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>            <span class="n">defRefCount</span><span class="o">(</span><span class="n">countObj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">releaseMemory</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">!=</span> <span class="n">Color</span><span class="o">.</span><span class="na">HATCH</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//对象的颜色不为 HATCH的时候，将其颜色标记为 HATCH，然后加入到队列中</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">HATCH</span><span class="o">;</span>
</span><span class='line'>        <span class="n">hatchQueue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>A</strong>的引用计数减少后的状态如下图，因为<strong>A</strong>的引用计数不为零，所以是疑似的循环垃圾，被标记成了<code>HATCH</code>。
<img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E7%A7%BB%E9%99%A4%E6%A0%B9%E5%88%B0A.png?x-oss-process=style/black" alt="A" /></p>

<p>引用计数触发回收的入口都在创建对象的时候，所以创建对象的代码也需要进行修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="n">ReferenceCountObj</span> <span class="nf">newObj</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Slot</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">applySlot</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">initObj</span><span class="o">(</span><span class="n">slot</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//新对象的颜色置为黑色</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span><span class="o">;</span>
</span><span class='line'>        <span class="n">allocatedObjList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">hatchQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//如果第一次分配失败，就尝试清理疑似垃圾</span>
</span><span class='line'>        <span class="n">scanHatchQueue</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">newObj</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nf">OutOfMemoryError</span><span class="o">(</span><span class="s">&quot;------ oh, out of memory! ------&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>scanHatchQueue</code>函数会执行可以循环垃圾的子图遍历。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">scanHatchQueue</span><span class="o">(){</span>
</span><span class='line'>    <span class="n">ReferenceCountObj</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">hatchQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">HATCH</span><span class="o">){</span>
</span><span class='line'>        <span class="c1">//通过以下三步找出循环垃圾并回收之</span>
</span><span class='line'>        <span class="n">paintGray</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="n">scanGray</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="n">collectWhite</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span><span class="k">else</span> <span class="nf">if</span><span class="o">(!</span><span class="n">hatchQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
</span><span class='line'>        <span class="n">scanHatchQueue</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>paintGray</code>函数会对目标对象进行试验删除，临时性的减少目标对象的引用计数，从而移除由内部引用产生的计数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 把对象的颜色置为 GRAY，对子对象计数器减1，递归调用 paintGray。</span>
</span><span class='line'><span class="cm"> * @param obj</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintGray</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">){</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span> <span class="o">||</span> <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">HATCH</span><span class="o">){</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">GRAY</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">ReferenceCountObj</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>            <span class="c1">// 这个地方非常重要，是子对象的计数器减1，而不是父对象。</span>
</span><span class='line'>            <span class="c1">// 否则会造成错误回收的情况。</span>
</span><span class='line'>            <span class="n">c</span><span class="o">.</span><span class="na">count</span><span class="o">--;</span>
</span><span class='line'>            <span class="n">paintGray</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对A及其子应用执行完<code>paintGray</code>后的状态。可以看到A,B,C,F都被标记成了灰色，A,B,C的计数为0，F的计数为1</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E6%89%AB%E6%8F%8FA.png?x-oss-process=style/black" alt="paintGray" /></p>

<p>下面详细的描述下过程:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E6%A0%87%E8%AE%B0%E5%90%8E.png?x-oss-process=style/black" alt="详细过程" /></p>

<p>首先，在(a)中A被涂成了灰色，程序对B进行了计数器减量操作。在(b)中B也被涂成了灰色，对C进行了减量操作。在&copy;中C被涂成了灰色，对A,F进行了计数器减量的操作。</p>

<p>接下来开始对灰色对象进行扫描。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">scanGray</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">GRAY</span><span class="o">){</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
</span><span class='line'>            <span class="c1">//如果经过paintGray操作后，引用计数还是大于零，</span>
</span><span class='line'>            <span class="c1">//对象肯定有来自其他对象的引用，则将对象的颜色标记为黑色</span>
</span><span class='line'>            <span class="n">paintBlack</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//对计数为零的对象标记为白色。</span>
</span><span class='line'>            <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">WHITE</span><span class="o">;</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">ReferenceCountObj</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>                <span class="n">scanGray</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行完<code>scanGray</code>之后的状态，A,B,C都被标记成了白色，F因为有来自E的引用，所以重新被标记成了黑色。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-scanGray.png?x-oss-process=style/black" alt="scanGray" /></p>

<p>最后就是对标记为白色对象进行回收了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">collectWhite</span><span class="o">(</span><span class="n">ReferenceCountObj</span> <span class="n">obj</span><span class="o">){</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="na">WHITE</span><span class="o">){</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Obj</span> <span class="n">child</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">ReferenceCountObj</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">ReferenceCountObj</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
</span><span class='line'>            <span class="n">collectWhite</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">releaseMemory</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>回收的状态如下图，至此循环垃圾已经被回收完成了。</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-collectWhite.png?x-oss-process=style/black" alt="回收完成" /></p>

<p>下图表示了在算法中四种颜色的变化示意图:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0-%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96.png?x-oss-process=style/black" alt="颜色变化" /></p>

<p><code>部分标记法</code>可以解决循环垃圾的问题，但是在效率上也存在不足。当对象很多的情况下，遍历对象的成本会变高，会增加垃圾回收的暂停时间。</p>

<h2>总结</h2>

<p>引用计数法虽然思想比较简单，但是工程实现上比较困难。在大型系统上基本上没有用武之地，但是在大多数对象的生命周期简单到直接进行管理的混合场景会比较有效。</p>
</div>
  <footer>
    <div class="articlemeta">
      <span class="hide">
        

<span class="categories">
  
    <a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/la-ji-hui-shou/'>垃圾回收</a>, <a class='category' href='/blog/categories/yin-yong-ji-shu-fa/'>引用计数法</a>
  
</span>

 @
        








  


<time datetime="2019-03-26T17:19:43+08:00" pubdate data-updated="true"></time>
      </span>
      <span class="plus">
        
          <a href="#disqus_thread" onclick="return false;" data-disqus-identifier="http://linuxlsx.github.io/blog/2019/03/26/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-yin-yong-ji-shu-fa/">+</a>
        
      </span>
    </div>
    
      <div class="sharing">
  
  
  
</div>

    
    <div class="meta">
      
        <a class="basic-alignment left" href="/blog/2019/03/21/arts-first-week/" title="Previous Post: ARTS 第1周 关键词匹配算法调研">&laquo; ARTS 第1周 关键词匹配算法调研</a>
      &nbsp;&nbsp;
      
        <a class="basic-alignment right" href="/blog/2019/03/29/arts-week-two/" title="Next Post: ARTS 第2周 GC引用计数算法"> ARTS 第2周 GC引用计数算法 &raquo;</a>
      
    </div>
  </footer>


</article>

  <section>
    <div class="hide" id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


    </div>
    <footer role="contentinfo"><div class="content">
  <p>
    Copyright &copy; 2019 linuxlsx
  </p>
</div>

</footer>
    

<script type="text/javascript">
  disqus_shortname = 'linuxlsx';
  
    disqus_identifier = 'http://linuxlsx.github.io/blog/2019/03/26/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-yin-yong-ji-shu-fa/';
    disqus_url = 'http://linuxlsx.github.io/blog/2019/03/26/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-yin-yong-ji-shu-fa/';
    function loadDisqus() {
      
      // var disqus_developer = 1;
      var disqus_script = 'embed.js';
      (function () {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }());
    }
  
  (function () {
    var disqus_script = 'count.js';
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
</script>











  </div>
  <script src="/javascripts/modernizr-2.0.js"></script>
<script src="https://code.jquery.com/jquery-1.9.1.min.js"></script>
<script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
<script src="/javascripts/libs/respond.js" type="text/javascript"></script>
<script src="/javascripts/octopress.js" type="text/javascript"></script>

  <script src="/javascripts/github.js" type="text/javascript"> </script>
  <script type="text/javascript">
  $(document).ready(function(){
    if (!window.jXHR){
      var jxhr = document.createElement('script');
      jxhr.type = 'text/javascript';
      jxhr.src = '/javascripts/libs/jXHR.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(jxhr, s);
    }

    github.showRepos({
      user: 'linuxlsx',
      count: 0,
      skip_forks: true,
      target: '#gh_repos'
    });
  });
  </script>


<script type="text/javascript">
$(document).ready(function(){
  var userAgent = navigator.userAgent.toLowerCase();
  var isiPhone = (userAgent.indexOf('iphone') != -1 || userAgent.indexOf('ipod') != -1) ? true : false;
  var isAndroid = (userAgent.indexOf('android') != -1) ? true : false;
  clickEvent = (isiPhone || isAndroid) ? 'touchstart' : 'click';
  $('#sidebar').on(clickEvent, function() {
    $(this).toggleClass('open');
  });
  $('.articlemeta').on(clickEvent, function() {
    toggleDisqus();
    $(this).toggleClass('open');
  });
});
</script>

</body>
</html>
