<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Arts | 平凡的世界]]></title>
  <link href="http://linuxlsx.github.io/blog/categories/arts/atom.xml" rel="self"/>
  <link href="http://linuxlsx.github.io/"/>
  <updated>2019-04-08T00:04:31+08:00</updated>
  <id>http://linuxlsx.github.io/</id>
  <author>
    <name><![CDATA[linuxlsx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Arts-week-three]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/04/08/arts-week-three/"/>
    <updated>2019-04-08T00:00:13+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/04/08/arts-week-three</id>
    <content type="html"><![CDATA[<h1>Algorithm</h1>

<p>本周完成的算法题: <a href="https://leetcode.com/problems/combination-sum/">Combination Sum</a></p>

<p>题目要求:</p>

<pre><code>给定一个不重复的数组(candidates)，以及一个目标(target)，从candidates找到所有的不重复的组合使得他们的和等于target。

Note:
1. 所有的数字都是正整数
2. 同一个数字可以无限次的重复使用
</code></pre>

<!--more-->


<p><strong>分析:</strong></p>

<p>这题可以通过回溯法来解决，通过递归下降多次遍历数组来寻找满足条件的组合。</p>

<pre><code class="Java">public class CombinationSum {

    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {

        List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(8);

        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        stack.ensureCapacity(candidates.length);
        calc(candidates, target, 0,new Stack&lt;&gt;(), lists);

        return lists;
    }

    /**
     * 递归下降深度优先遍历。 算法复杂度 O((n^2 + n) / 2)
     * 最终结果是 6ms  beats 92%
     *
     * 分析了排在更前面的实现，发现主要的差异就是他们用List替代了Stack
     * 来保存中间状态，这样可以减少一个subList的操作。基本上可以到2ms
     *
     * @param candidates
     * @param target
     * @param start
     * @param stack         需要使用栈来保存中间状态。
     * @param lists
     */
    private void calc(int[] candidates, int target, int start, Stack&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; lists){

        for (int i = start; i &lt; candidates.length; i++) {

            if(candidates[i] &gt; target){
                continue;
            }

            stack.push(candidates[i]);
            if(candidates[i] == target){
                List&lt;Integer&gt; l = new ArrayList&lt;&gt;(stack.size());
                l.addAll(stack.subList(0, stack.size()));
                lists.add(l);
            }else if(candidates[i] &lt; target) {
                calc(candidates, target - candidates[i], i ,stack , lists);
            }
            stack.pop();
        }
    }
}    
</code></pre>

<h1>Review</h1>

<p>本周Review <a href="https://medium.com/netflix-techblog/building-and-scaling-data-lineage-at-netflix-to-improve-data-infrastructure-reliability-and-1a52526a7977">Building and Scaling Data Lineage at Netflix to Improve Data Infrastructure Reliability, and Efficiency</a></p>

<p>本文是Netflix的一篇技术文章。讲述了Netflix内部是如何构建一个数据链路关系系统的。</p>

<p>公司从小到大的过程中，一定会伴随着数据越来越多，数据链路越来越复杂。很快就没有人能够了解数据全貌了。文章开篇提了三个场景:</p>

<ul>
<li>假设你是一个决策者，当你要根据数据看报做一个关键决策时，是否可以自己去验证下看报背后的数据到底是什么</li>
<li>假设你是一个开发者，当你决定要修改你提供的服务的数据结构时，是否可以知道哪些下游会受到影响</li>
<li>假设你现在负责平台的可靠性，你的任务是主动监测上游任务的问题，提前给数据作业owner报警。你要设计一个SLA预警系统，需要用到上下游数据依赖以及历史状态数据。<code>(Finally, imagine yourself in the role of a data platform reliability engineer tasked with providing advanced lead time to data pipeline (ETL) owners by proactively identifying issues upstream to their ETL jobs. You are designing a learning system to forecast Service Level Agreement (SLA) violations and would want to factor in all upstream dependencies and corresponding historical states)</code></li>
</ul>


<p>要满足以上的需求，就需要有一个 <code>complete and accurate data lineage system</code>。</p>

<p>自由和责任是Netflix内部文化的重要部分。核心思想是你可以自由的选择实现方式，但是要为其负责。同样这样的自由也会导致公司内部技术栈的多样性，同样也会带来更多的负责度。作者就面临这样的问题。以下是Netflix 的一个<code>Data Landscape</code>。</p>

<p><img src="https://cdn-images-1.medium.com/max/1400/0*gYI3uCywVhSrcoRo" alt="Data Landscape" /></p>

<p>为了满足Netflix内部多样化的数据，<code>Data Lineage</code>有以下的几个设计原则：</p>

<ul>
<li><code>Ensure data integrity</code> 数据完整性。 需要精确完整的保存数据关系来建立用户的信心。一个不完全可行系统带来伤害可能多过好处。</li>
<li><code>Enable seamless intergration</code> 无缝接入。需要能够满足新的数据工具快速接入。</li>
<li><code>Design a flexible data model</code> 灵活的数据结构。使用一个通用灵活的数据模型来表示不同的数据来源。</li>
</ul>


<p>最终的系统实现图如下：</p>

<p><img src="https://cdn-images-1.medium.com/max/2600/0*Xp1KHPFm1R7GZGAI" alt="系统实现图" /></p>

<p>解释下这个图：</p>

<p>首先左侧是数据接入层，每个业务系统都有它自己独立数据处理逻辑，独立的数据模型。所以在使用之前需要统一进行转换。</p>

<p>中间一层就是数据转换层，转换层将所有收集上来的数据进行转换，统一用点和边的图模式表达。数据转换完毕后会将数据存储到图数据库中。</p>

<p>右侧就是数据存储和服务层。在数据之上建立了的REST服务层，对外提供数据服务。</p>

<h1>Tip</h1>

<p>在Java中很多情况需要对一些特殊字符做一些转义。那么一般的写法就是为罗列出所有的需要进行替换的字符，然后不停的调用replace。比如像下面的代码：</p>

<pre><code class="Java">keyword.replace("\\", "\\\\").replace("*", "\\*")
                .replace("+", "\\+").replace("|", "\\|")
                .replace("{", "\\{").replace("}", "\\}")
                .replace("(", "\\(").replace(")", "\\)")
                .replace("^", "\\^").replace("$", "\\$")
                .replace("[", "\\[").replace("]", "\\]")
                .replace("?", "\\?").replace(",", "\\,")
                .replace(".", "\\.").replace("&amp;", "\\&amp;")
                .replace("-", "\\-");
</code></pre>

<p>这样写虽然能够完成需求，但是不太优雅。在Java的正则表达式中实际是可以支持类似<code>$0 $1</code>这样的占位符的。那么像<code>.replace("[", "\\[")</code> 可以改写成 <code>.replace("[", "\\$0")</code>。</p>

<p>在这个实现中，<code>$0</code> 代表的是整个正则的匹配结果，<code>$1 $2...$n</code> 代表的是从1-n的捕获组的内容。</p>

<p>具体的捕获组的介绍可以参考：<a href="https://blog.csdn.net/just4you/article/details/70767928">正则表达式的捕获组(capture group)在Java中的使用</a></p>

<p>上面的语句改成类似形式的案例：</p>

<pre><code class="Java">String s = "\\*+|{}^$[]?,.&amp;-";
System.out.println(s);
System.out.println(s.replaceAll("[\\\\\\*\\+\\|\\{\\}\\(\\)\\^\\$\\[\\]\\?\\,\\.\\&amp;\\-]", "\\\\$0"));

//输出
\*+|{}^$[]?,.&amp;-
\\\*\+\|\{\}\^\$\[\]\?\,\.\&amp;\-
</code></pre>

<h1>Share</h1>

<p><a href="http://linuxlsx.top/blog/2019/04/07/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-fu-zhi-suan-fa/">GC算法-复制算法</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arts-week-two]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/03/29/arts-week-two/"/>
    <updated>2019-03-29T21:25:12+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/03/29/arts-week-two</id>
    <content type="html"><![CDATA[<h1>ARTS 第2周</h1>

<h2>Algorithm</h2>

<p>本周完成的算法题: <a href="https://leetcode.com/problems/valid-sudoku/">Valid Sudoku</a></p>

<p>题目要求:</p>

<pre><code>通过二维数组定义了9x9的数独库，这个数独库的某些位置会被数字填充，其他地方填充'.'，现在需要你来验证这个数独库是否合法的。有效数独的规则如下:

1. 每一行都是1-9不重复的数字
2. 每一列都是1-9不重复的数字
3. 每一个3x3的小方格中也是1-9不重复的数字
</code></pre>

<!-- more -->


<p><strong>分析:</strong></p>

<p>要完成有效性的判定，双重循环遍历是肯定要的。我们需要考虑的是如何只使用双重循环就把所有事情搞定。通过对矩阵的观察，我们发现有以下的规律:</p>

<ul>
<li>当我们访问<code>soduku[i][j]</code>，通过转换顺序<code>soduku[j][i]</code>，这样可以同时访问一行、一列。</li>
<li>可以通过 <code>(i / 3) 和 (j / 3)</code>得到一个<code>3x3</code>小方格，同时通过<code>(i % 3) * 3 + j % 3</code>计算出<code>sudoku[i][j]</code>在小方格中的位置。</li>
</ul>


<p>通过以上两个规律，我们就可以在<code>n * n</code>次循环中得出是否合法的结果。</p>

<pre><code class="Java">class Solution {
    public boolean isValidSudoku(char[][] board) {

        //实现的比较挫，这里定了9个数组用来代表9个 3x3的小方格
        char[] rect0 = {'.','.','.','.','.','.','.','.','.'};
        char[] rect1 = {'.','.','.','.','.','.','.','.','.'};
        char[] rect2 = {'.','.','.','.','.','.','.','.','.'};
        char[] rect3 = {'.','.','.','.','.','.','.','.','.'};
        char[] rect4 = {'.','.','.','.','.','.','.','.','.'};
        char[] rect5 = {'.','.','.','.','.','.','.','.','.'};
        char[] rect6 = {'.','.','.','.','.','.','.','.','.'};
        char[] rect7 = {'.','.','.','.','.','.','.','.','.'};
        char[] rect8 = {'.','.','.','.','.','.','.','.','.'};

        Map&lt;String, char[]&gt; maps = new HashMap&lt;&gt;();
        maps.put("0_0", rect0);
        maps.put("0_1", rect1);
        maps.put("0_2", rect2);
        maps.put("1_0", rect3);
        maps.put("1_1", rect4);
        maps.put("1_2", rect5);
        maps.put("2_0", rect6);
        maps.put("2_1", rect7);
        maps.put("2_2", rect8);

        for (int i = 0; i &lt; 9; i++) {
            char[] hor_array = {'.','.','.','.','.','.','.','.','.'};
            char[] ver_array = {'.','.','.','.','.','.','.','.','.'};
            for (int j = 0; j &lt; 9; j++) {
                //行
                char hor_char = board[i][j];
                //列
                char ver_char = board[j][i];

                //如果第一次出现，则把对应的位置替换为对应的内容
                //如果第二次出现，那么内容就不是初始值了，可以认定是invalid
                if(hor_char != '.'){
                    if(hor_array[hor_char - '0'] == '.'){
                        hor_array[hor_char - '0'] = hor_char;
                    }else {
                        return false;
                    }

                    //计算当前位置所属的小方格
                    String key = (i / 3) + "_" + (j / 3);
                    //int index = (i % 3) * 3 + j % 3;
                    char[] rect = maps.get(key);
                    if (rect[hor_char - '0'] == '.') {
                        rect[hor_char - '0'] = hor_char;
                    }else {
                        return false;
                    }
                }

                if(ver_char != '.'){
                    if(ver_array[ver_char - 49] == '.'){
                        ver_array[ver_char - 49] = ver_char;
                    }else {
                        return false;
                    }
                }
            }
        }

        return true;
    }
}
</code></pre>

<p>实现思路上算是正确的，但不是最优的哈。最优代码参考:</p>

<pre><code class="Java">    /**
     * 最快的版本。 10ms  beats 100%。
     * 对于每个横、竖和3x3 进行 `|` 操作，这样通过 `&amp;`操作就能知道这个数字是否重复过。
     * @param board
     * @return
     */
    public boolean isValidSudokuFastest(char[][] board) {

        int [] vset = new int [9];
        int [] hset = new int [9];
        int [] bckt = new int [9];
        int idx = 0;
        for (int i = 0; i &lt; 9; i++) {
            for (int j = 0; j &lt; 9; j++) {
                if (board[i][j] != '.') {
                    idx = 1 &lt;&lt; (board[i][j] - '0') ;
                    if ((hset[i] &amp; idx) &gt; 0 ||
                            (vset[j] &amp; idx) &gt; 0 ||
                            (bckt[(i / 3) * 3 + j / 3] &amp; idx) &gt; 0) return false;
                    hset[i] |= idx;
                    vset[j] |= idx;
                    bckt[(i / 3) * 3 + j / 3] |= idx;
                }
            }
        }
        return true;

    }
</code></pre>

<h2>Review</h2>

<p>本周Review <a href="https://medium.com/s/story/the-law-of-two-thirds-cfad7c4d42eb">A Technique for Deciding When to Say No</a></p>

<p><code>人不能完成所有事情，所以我们需要对要做的事情，想要的东西做取舍。当你选择某些项的时候，也就舍弃了其他的</code></p>

<p>文章中提出了一个<code>2-3</code>法则，就是说在3个关键要素中，你只能同时选择两个。比如：质量、速度和价格，只能选择两个。如果你想要质量和速度，那么价格必然就贵；你想要低价同时也想保持质量，那么速度必然受到影响；你想要低价和速度，那么质量就无法保证。</p>

<p>这个观点和我们程序员熟悉的<code>CAP</code>理论有异曲同工之妙，同样的三个要素，不可兼得。</p>

<p>那么怎么样来进行选择呢？那么首先要弄明白的是你想要的到底是什么？这里要记住：<code>你是不可能做所有事情，得到所有东西的</code>。</p>

<p>对于生活，一定不要让自己时时处于忙碌的状态，忙碌意味着你不知道你想要的是什么，你不知道对什么说<strong>不</strong>，所以你的时间被无关的事情给占有了。</p>

<h2>Tip</h2>

<p><strong>在数据量大的情况下，任何系统的性能隐患都被放大直到系统崩溃。</strong></p>

<p>在本周有一个算法同学写了一段类似如下的大数据处理SQL：</p>

<pre><code class="SQL">select col1, col2, process(col4, map('{1,2,3,4,5}')) from table_a
</code></pre>

<p>SQL 很简单，<code>process</code> 和 <code>map</code>都是自定的函数。其中<code>map</code>函数会将参数转化成一个map结构。但是在实际运行的时候发现性能很差，100亿条数据执行了9个多小时。他找我帮他看看问题在哪里？</p>

<p>问题其实就是<code>map</code>函数导致的，这个sql每处理一条数据就会调用<code>map</code>函数，就会创建一个新对象。同时因为参数比较长，会多次触发map的扩容，导致整个SQL执行99%以上的时间其实在创建map和扩容中。</p>

<p>当修改实现改成使用缓存以后，性能溜得飞起，只要了<strong>4分钟</strong>就完成了。</p>

<p>在大数据环境下，对象的创建其实是很昂贵的操作。所以像<code>Hadoop</code>这样的大数据框架才会设计成对象复用。</p>

<h2>Share</h2>

<p><a href="http://linuxlsx.top/blog/2019/03/26/la-ji-hui-shou-de-suan-fa-yu-shi-xian-du-shu-bi-ji-yin-yong-ji-shu-fa/">GC算法-引用计数法</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARTS First Week]]></title>
    <link href="http://linuxlsx.github.io/blog/2019/03/21/arts-first-week/"/>
    <updated>2019-03-21T23:09:03+08:00</updated>
    <id>http://linuxlsx.github.io/blog/2019/03/21/arts-first-week</id>
    <content type="html"><![CDATA[<h1>ARTS 第1周</h1>

<h2>Algorithm</h2>

<p>本周完成的算法题: <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></p>

<p>题目要求:</p>

<pre><code>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].
</code></pre>

<p><strong>分析:</strong></p>

<p>在<code>O(log n)</code> 时间复杂度的限制下，肯定是要用二分查找的。但是与普通的查找不同，这个题目实际的要求是查找目标的<code>左边界</code>和<code>右边界</code>。这样我们通过二分法查找到目标值以后，<strong>不能立刻返回</strong>，而是要继续向左或者向右查看是否有更左或者更右的目标。所以通过两次二分查找即可得到想要的结果。时间复杂度为 <code>2 * O(log n)</code></p>

<p>代码实际比较简单，就不贴代码了。</p>

<h2>Review</h2>

<p>本周Review <a href="https://medium.com/s/the-nuance/why-your-brain-needs-idle-time-e5d90b0ef1df">Why Your Brain Needs Idle Time</a></p>

<p><code>适当的休息更有助于学习和消化知识</code></p>

<p>每个人的精力是有限的，每天的工作和社交活动占用了很大的一部分，很多人只有在晚上淋浴和准备睡觉的时候才能让放松下来。</p>

<p>文中研究了<code>适当休息</code>是否会对老鼠过迷宫速度有影响。两只老鼠，一只通过迷宫后会休息下然后再重走一次迷宫，而另一只不休息直接重走。结果表明：休息过的老鼠第二次走迷宫的速度会比不休息的要<strong>快</strong>。</p>

<p>所以，不是总是让自己的大脑处于负荷运行的情况，适当的休息并不会降低效率，相反会提高效率。</p>

<h2>Tip</h2>

<p>在写代码过程中经常会碰到用一个Map来保存(K,V)结构，如果一个K有多个V的时候，我们需要指定<code>List&lt;V&gt;</code>来保存。最近我碰到了一个新的用法，使用<code>apache-commons 4</code>中的 <code>MultiValuedMap</code>可以帮助我们简化代码。</p>

<p>MultiValuedMap 的类结构如下图:</p>

<p><img src="http://0bb6ac2.oss-cn-hongkong.aliyuncs.com/image/multihashmap.jpg?x-oss-process=style/origin" alt="类结构" /></p>

<p>主要提供了两种实现：基于ArrayList的实现和基于HashSet的实现。主要区别就是在于对于<code>Key</code>是否允许重复的<code>V</code>存在。</p>

<h2>Share</h2>

<p><a href="http://linuxlsx.top/blog/2019/03/21/guan-jian-ci-pi-pei-suan-fa-diao-yan/">关键词匹配算法调研</a></p>
]]></content>
  </entry>
  
</feed>
